(dlv) break main.go:*
(dlv) funcs  main.go
(dlv) funcs  /^main/
(dlv) funcs
_rt0_amd64
_rt0_amd64_darwin
aeshashbody
callRet
cmpbody
debugCall1024
debugCall128
debugCall16384
debugCall2048
debugCall256
debugCall32
debugCall32768
debugCall4096
debugCall512
debugCall64
debugCall65536
debugCall8192
errors.(*errorString).Error
errors.New
errors.init
fmt.(*buffer).write
fmt.(*buffer).writeByte
fmt.(*buffer).writeRune
fmt.(*buffer).writeString
fmt.(*fmt).clearflags
fmt.(*fmt).fmtBoolean
fmt.(*fmt).fmtBs
fmt.(*fmt).fmtBx
fmt.(*fmt).fmtC
fmt.(*fmt).fmtFloat
fmt.(*fmt).fmtInteger
fmt.(*fmt).fmtQ
fmt.(*fmt).fmtQc
fmt.(*fmt).fmtS
fmt.(*fmt).fmtSbx
fmt.(*fmt).fmtSx
fmt.(*fmt).fmtUnicode
fmt.(*fmt).init
fmt.(*fmt).pad
fmt.(*fmt).padString
fmt.(*fmt).truncate
fmt.(*fmt).truncateString
fmt.(*fmt).writePadding
fmt.(*pp).Write
fmt.(*pp).badVerb
fmt.(*pp).catchPanic
fmt.(*pp).doPrintln
fmt.(*pp).fmt0x64
fmt.(*pp).fmtBool
fmt.(*pp).fmtBytes
fmt.(*pp).fmtComplex
fmt.(*pp).fmtFloat
fmt.(*pp).fmtInteger
fmt.(*pp).fmtPointer
fmt.(*pp).fmtString
fmt.(*pp).free
fmt.(*pp).handleMethods
fmt.(*pp).handleMethods.func1
fmt.(*pp).handleMethods.func2
fmt.(*pp).handleMethods.func3
fmt.(*pp).handleMethods.func4
fmt.(*pp).printArg
fmt.(*pp).printValue
fmt.(*pp).unknownType
fmt.Fprintln
fmt.Println
fmt.getField
fmt.glob..func1
fmt.init
fmt.newPrinter
gogo
gosave_systemstack_switch
indexbytebody
internal/abi.(*IntArgRegBitmap).Get
internal/abi.(*IntArgRegBitmap).Set
internal/abi.(*RegArgs).IntRegArgAddr
internal/bytealg.IndexByteString
internal/bytealg.init.0
internal/cpu.Initialize
internal/cpu.cpuid
internal/cpu.doinit
internal/cpu.indexByte
internal/cpu.isSet
internal/cpu.processOptions
internal/cpu.xgetbv
internal/fmtsort.(*SortedMap).Len
internal/fmtsort.(*SortedMap).Less
internal/fmtsort.(*SortedMap).Swap
internal/fmtsort.Sort
internal/fmtsort.compare
internal/fmtsort.floatCompare
internal/fmtsort.isNaN
internal/fmtsort.nilCompare
internal/itoa.Itoa
internal/itoa.Uitoa
internal/oserror.init
internal/poll.(*DeadlineExceededError).Error
internal/poll.(*FD).Close
internal/poll.(*FD).Init
internal/poll.(*FD).Write
internal/poll.(*FD).Write.func1
internal/poll.(*FD).decref
internal/poll.(*FD).destroy
internal/poll.(*FD).writeLock
internal/poll.(*FD).writeUnlock
internal/poll.(*errNetClosing).Error
internal/poll.(*fdMutex).decref
internal/poll.(*fdMutex).increfAndClose
internal/poll.(*fdMutex).rwlock
internal/poll.(*fdMutex).rwunlock
internal/poll.(*pollDesc).close
internal/poll.(*pollDesc).evict
internal/poll.(*pollDesc).init
internal/poll.(*pollDesc).pollable
internal/poll.(*pollDesc).prepare
internal/poll.(*pollDesc).prepareWrite
internal/poll.(*pollDesc).wait
internal/poll.(*pollDesc).waitWrite
internal/poll.convertErr
internal/poll.errClosing
internal/poll.errNetClosing.Error
internal/poll.errnoErr
internal/poll.ignoringEINTRIO
internal/poll.init
internal/poll.runtime_Semacquire
internal/poll.runtime_Semrelease
internal/poll.runtime_pollClose
internal/poll.runtime_pollOpen
internal/poll.runtime_pollReset
internal/poll.runtime_pollServerInit
internal/poll.runtime_pollUnblock
internal/poll.runtime_pollWait
internal/race.Enable
internal/reflectlite.(*Kind).String
internal/reflectlite.(*rtype).Elem
internal/reflectlite.(*rtype).Kind
internal/reflectlite.(*rtype).Len
internal/reflectlite.(*rtype).String
internal/reflectlite.(*rtype).nameOff
internal/reflectlite.Kind.String
internal/reflectlite.TypeOf
internal/reflectlite.add
internal/reflectlite.name.data
internal/reflectlite.name.name
internal/reflectlite.name.readVarint
internal/reflectlite.resolveNameOff
internal/reflectlite.toType
internal/syscall/unix.IsNonblock
internal/testlog.Getenv
internal/testlog.Logger
io.init
io/fs.(*FileMode).String
io/fs.(*PathError).Error
io/fs.FileMode.String
io/fs.errClosed
io/fs.errExist
io/fs.errInvalid
io/fs.errNotExist
io/fs.errPermission
io/fs.init
main.CanEnd
main.getMaxofSmaller
main.getMinOfGreater
main.main
main.oddEvenJumps
math.Float32bits
math.Float64bits
math.init
math/bits.TrailingZeros
memeqbody
os.(*File).Write
os.(*File).checkValid
os.(*File).wrapErr
os.(*File).write
os.(*SyscallError).Error
os.(*dirInfo).close
os.(*file).close
os.Getenv
os.Getwd
os.NewFile
os.NewSyscallError
os.SameFile
os.basename
os.epipecheck
os.errDeadlineExceeded
os.errNoDeadline
os.fillFileStatFromSys
os.ignoringEINTR
os.init
os.init.0
os.newFile
os.newFile.func1
os.runtime_args
os.sameFile
os.sigpipe
os.statNolog
os.statNolog.func1
os.timespecToTime
os/signal.signal_ignored
path.init
reflect.(*ChanDir).String
reflect.(*Kind).String
reflect.(*MapIter).Key
reflect.(*MapIter).Next
reflect.(*MapIter).Value
reflect.(*Value).Kind
reflect.(*Value).Len
reflect.(*Value).String
reflect.(*ValueError).Error
reflect.(*abiSeq).addArg
reflect.(*abiSeq).addRcvr
reflect.(*abiSeq).assignFloatN
reflect.(*abiSeq).assignIntN
reflect.(*abiSeq).regAssign
reflect.(*abiSeq).stackAssign
reflect.(*abiSeq).stepsForValue
reflect.(*bitVector).append
reflect.(*funcType).Elem
reflect.(*funcType).Field
reflect.(*funcType).Kind
reflect.(*funcType).Len
reflect.(*funcType).String
reflect.(*funcType).in
reflect.(*funcType).out
reflect.(*hiter).initialized
reflect.(*interfaceType).NumMethod
reflect.(*rtype).Elem
reflect.(*rtype).Field
reflect.(*rtype).Kind
reflect.(*rtype).Len
reflect.(*rtype).NumMethod
reflect.(*rtype).Size
reflect.(*rtype).String
reflect.(*rtype).common
reflect.(*rtype).exportedMethods
reflect.(*rtype).nameOff
reflect.(*rtype).pointers
reflect.(*rtype).textOff
reflect.(*rtype).typeOff
reflect.(*rtype).uncommon
reflect.(*structField).embedded
reflect.(*structField).offset
reflect.(*structType).Field
reflect.(*uncommonType).exportedMethods
reflect.ChanDir.String
reflect.Kind.String
reflect.TypeOf
reflect.Value.Bool
reflect.Value.Bytes
reflect.Value.CanAddr
reflect.Value.CanInterface
reflect.Value.Complex
reflect.Value.Elem
reflect.Value.Field
reflect.Value.Float
reflect.Value.Index
reflect.Value.Int
reflect.Value.Interface
reflect.Value.IsNil
reflect.Value.IsValid
reflect.Value.Kind
reflect.Value.Len
reflect.Value.MapRange
reflect.Value.NumField
reflect.Value.NumMethod
reflect.Value.Pointer
reflect.Value.Slice
reflect.Value.String
reflect.Value.Type
reflect.Value.Uint
reflect.Value.pointer
reflect.ValueOf
reflect.add
reflect.addReflectOff
reflect.addTypeBits
reflect.align
reflect.archFloat32FromReg
reflect.archFloat32ToReg
reflect.arrayAt
reflect.callMethod
reflect.callMethod
reflect.chanlen
reflect.copyVal
reflect.escapes
reflect.flag.kind
reflect.flag.mustBe
reflect.flag.ro
reflect.floatFromReg
reflect.floatToReg
reflect.funcLayout
reflect.funcLayout.func1
reflect.ifaceIndir
reflect.init
reflect.intFromReg
reflect.intToReg
reflect.makeMethodValue
reflect.mapiterelem
reflect.mapiterinit
reflect.mapiterkey
reflect.mapiternext
reflect.maplen
reflect.memmove
reflect.methodName
reflect.methodReceiver
reflect.methodValueCall
reflect.methodValueCallCodePtr
reflect.moveMakeFuncArgPtrs
reflect.moveMakeFuncArgPtrs
reflect.name.data
reflect.name.hasTag
reflect.name.isExported
reflect.name.name
reflect.name.readVarint
reflect.name.tag
reflect.newAbiDesc
reflect.newName
reflect.packEface
reflect.resolveNameOff
reflect.resolveReflectName
reflect.resolveTextOff
reflect.resolveTypeOff
reflect.storeRcvr
reflect.toType
reflect.typedmemclr
reflect.typedmemmove
reflect.unpackEface
reflect.unsafe_New
reflect.valueInterface
reflect.verifyNotInHeapPtr
reflect.writeVarint
runtime.(*Frames).Next
runtime.(*Func).Entry
runtime.(*Func).Name
runtime.(*Func).funcInfo
runtime.(*Func).raw
runtime.(*TypeAssertionError).Error
runtime.(*_func).funcInfo
runtime.(*_func).isInlined
runtime.(*_type).nameOff
runtime.(*_type).pkgpath
runtime.(*_type).string
runtime.(*_type).textOff
runtime.(*_type).typeOff
runtime.(*_type).uncommon
runtime.(*activeSweep).begin
runtime.(*activeSweep).end
runtime.(*activeSweep).isDone
runtime.(*activeSweep).markDrained
runtime.(*activeSweep).reset
runtime.(*activeSweep).sweepers
runtime.(*addrRanges).add
runtime.(*addrRanges).cloneInto
runtime.(*addrRanges).findAddrGreaterEqual
runtime.(*addrRanges).findSucc
runtime.(*addrRanges).init
runtime.(*addrRanges).removeGreaterEqual
runtime.(*addrRanges).removeLast
runtime.(*bmap).keys
runtime.(*bmap).overflow
runtime.(*bmap).setoverflow
runtime.(*boundsError).Error
runtime.(*bucket).bp
runtime.(*bucket).mp
runtime.(*bucket).stk
runtime.(*consistentHeapStats).acquire
runtime.(*consistentHeapStats).release
runtime.(*cpuProfile).add
runtime.(*cpuProfile).addExtra
runtime.(*cpuProfile).addNonGo
runtime.(*errorAddressString).Error
runtime.(*errorString).Error
runtime.(*fixalloc).alloc
runtime.(*fixalloc).free
runtime.(*fixalloc).init
runtime.(*functype).dotdotdot
runtime.(*functype).in
runtime.(*functype).out
runtime.(*gList).empty
runtime.(*gList).pop
runtime.(*gList).push
runtime.(*gList).pushAll
runtime.(*gQueue).empty
runtime.(*gQueue).pop
runtime.(*gQueue).popList
runtime.(*gQueue).push
runtime.(*gQueue).pushBack
runtime.(*gQueue).pushBackAll
runtime.(*gcBits).bitp
runtime.(*gcBits).bytep
runtime.(*gcBitsArena).tryAlloc
runtime.(*gcControllerState).addGlobals
runtime.(*gcControllerState).addScannableStack
runtime.(*gcControllerState).commit
runtime.(*gcControllerState).endCycle
runtime.(*gcControllerState).enlistWorker
runtime.(*gcControllerState).findRunnableGCWorker
runtime.(*gcControllerState).findRunnableGCWorker.func1
runtime.(*gcControllerState).init
runtime.(*gcControllerState).logWorkTime
runtime.(*gcControllerState).resetLive
runtime.(*gcControllerState).revise
runtime.(*gcControllerState).setGCPercent
runtime.(*gcControllerState).startCycle
runtime.(*gcControllerState).update
runtime.(*gcWork).balance
runtime.(*gcWork).dispose
runtime.(*gcWork).empty
runtime.(*gcWork).init
runtime.(*gcWork).put
runtime.(*gcWork).putBatch
runtime.(*gcWork).putFast
runtime.(*gcWork).tryGet
runtime.(*gcWork).tryGetFast
runtime.(*guintptr).cas
runtime.(*guintptr).set
runtime.(*hchan).raceaddr
runtime.(*headTailIndex).cas
runtime.(*headTailIndex).incTail
runtime.(*headTailIndex).load
runtime.(*headTailIndex).reset
runtime.(*hmap).createOverflow
runtime.(*hmap).growing
runtime.(*hmap).incrnoverflow
runtime.(*hmap).newoverflow
runtime.(*hmap).noldbuckets
runtime.(*hmap).oldbucketmask
runtime.(*hmap).sameSizeGrow
runtime.(*itab).init
runtime.(*itabTableType).add
runtime.(*itabTableType).add-fm
runtime.(*itabTableType).find
runtime.(*lfstack).empty
runtime.(*lfstack).pop
runtime.(*lfstack).push
runtime.(*linearAlloc).alloc
runtime.(*lockRank).String
runtime.(*mSpanList).init
runtime.(*mSpanList).insert
runtime.(*mSpanList).isEmpty
runtime.(*mSpanList).remove
runtime.(*mSpanList).takeAll
runtime.(*mSpanStateBox).get
runtime.(*mSpanStateBox).set
runtime.(*maptype).hashMightPanic
runtime.(*maptype).indirectelem
runtime.(*maptype).indirectkey
runtime.(*maptype).needkeyupdate
runtime.(*maptype).reflexivekey
runtime.(*markBits).advance
runtime.(*mcache).allocLarge
runtime.(*mcache).nextFree
runtime.(*mcache).prepareForSweep
runtime.(*mcache).refill
runtime.(*mcache).releaseAll
runtime.(*mcentral).cacheSpan
runtime.(*mcentral).fullSwept
runtime.(*mcentral).fullUnswept
runtime.(*mcentral).grow
runtime.(*mcentral).init
runtime.(*mcentral).partialSwept
runtime.(*mcentral).partialUnswept
runtime.(*mcentral).uncacheSpan
runtime.(*memRecordCycle).add
runtime.(*mheap).alloc
runtime.(*mheap).alloc.func1
runtime.(*mheap).allocMSpanLocked
runtime.(*mheap).allocManual
runtime.(*mheap).allocNeedsZero
runtime.(*mheap).allocSpan
runtime.(*mheap).freeMSpanLocked
runtime.(*mheap).freeManual
runtime.(*mheap).freeSpan
runtime.(*mheap).freeSpan.func1
runtime.(*mheap).freeSpanLocked
runtime.(*mheap).grow
runtime.(*mheap).init
runtime.(*mheap).nextSpanForSweep
runtime.(*mheap).reclaim
runtime.(*mheap).reclaimChunk
runtime.(*mheap).setSpans
runtime.(*mheap).sysAlloc
runtime.(*mheap).tryAllocMSpan
runtime.(*moduledata).textAddr
runtime.(*moduledata).textOff
runtime.(*mspan).allocBitsForIndex
runtime.(*mspan).base
runtime.(*mspan).countAlloc
runtime.(*mspan).divideByElemSize
runtime.(*mspan).ensureSwept
runtime.(*mspan).init
runtime.(*mspan).isFree
runtime.(*mspan).markBitsForBase
runtime.(*mspan).markBitsForIndex
runtime.(*mspan).nextFreeIndex
runtime.(*mspan).objIndex
runtime.(*mspan).refillAllocCache
runtime.(*mspan).reportZombies
runtime.(*muintptr).set
runtime.(*notInHeap).add
runtime.(*p).destroy
runtime.(*p).destroy.func1
runtime.(*p).init
runtime.(*pageAlloc).alloc
runtime.(*pageAlloc).allocRange
runtime.(*pageAlloc).allocToCache
runtime.(*pageAlloc).chunkOf
runtime.(*pageAlloc).find
runtime.(*pageAlloc).find.func1
runtime.(*pageAlloc).findMappedAddr
runtime.(*pageAlloc).free
runtime.(*pageAlloc).grow
runtime.(*pageAlloc).init
runtime.(*pageAlloc).scavenge
runtime.(*pageAlloc).scavenge.func1
runtime.(*pageAlloc).scavengeOne
runtime.(*pageAlloc).scavengeOne.func1
runtime.(*pageAlloc).scavengeOneFast
runtime.(*pageAlloc).scavengeRangeLocked
runtime.(*pageAlloc).scavengeReserve
runtime.(*pageAlloc).scavengeStartGen
runtime.(*pageAlloc).scavengeUnreserve
runtime.(*pageAlloc).sysGrow
runtime.(*pageAlloc).sysGrow.func1
runtime.(*pageAlloc).sysGrow.func2
runtime.(*pageAlloc).sysGrow.func3
runtime.(*pageAlloc).sysInit
runtime.(*pageAlloc).update
runtime.(*pageBits).block64
runtime.(*pageBits).clear
runtime.(*pageBits).clearAll
runtime.(*pageBits).clearBlock64
runtime.(*pageBits).clearRange
runtime.(*pageBits).popcntRange
runtime.(*pageBits).set
runtime.(*pageBits).setAll
runtime.(*pageBits).setBlock64
runtime.(*pageBits).setRange
runtime.(*pageCache).alloc
runtime.(*pageCache).allocN
runtime.(*pageCache).empty
runtime.(*pageCache).flush
runtime.(*pallocBits).allocAll
runtime.(*pallocBits).allocPages64
runtime.(*pallocBits).allocRange
runtime.(*pallocBits).find
runtime.(*pallocBits).find1
runtime.(*pallocBits).findLargeN
runtime.(*pallocBits).findSmallN
runtime.(*pallocBits).free
runtime.(*pallocBits).free1
runtime.(*pallocBits).freeAll
runtime.(*pallocBits).pages64
runtime.(*pallocBits).summarize
runtime.(*pallocData).allocAll
runtime.(*pallocData).allocRange
runtime.(*pallocData).findScavengeCandidate
runtime.(*pallocData).hasScavengeCandidate
runtime.(*piController).next
runtime.(*piController).reset
runtime.(*plainError).Error
runtime.(*pollCache).alloc
runtime.(*pollCache).free
runtime.(*pollDesc).info
runtime.(*pollDesc).publishInfo
runtime.(*pollDesc).setEventErr
runtime.(*profAtomic).cas
runtime.(*profAtomic).load
runtime.(*profBuf).canWriteRecord
runtime.(*profBuf).canWriteTwoRecords
runtime.(*profBuf).hasOverflow
runtime.(*profBuf).incrementOverflow
runtime.(*profBuf).takeOverflow
runtime.(*profBuf).wakeupExtra
runtime.(*profBuf).write
runtime.(*puintptr).set
runtime.(*randomEnum).done
runtime.(*randomEnum).next
runtime.(*randomEnum).position
runtime.(*randomOrder).reset
runtime.(*randomOrder).start
runtime.(*rwmutex).rlock
runtime.(*rwmutex).rlock.func1
runtime.(*rwmutex).runlock
runtime.(*semaRoot).dequeue
runtime.(*semaRoot).queue
runtime.(*semaRoot).rotateLeft
runtime.(*semaRoot).rotateRight
runtime.(*sigctxt).cs
runtime.(*sigctxt).fault
runtime.(*sigctxt).fixsigcode
runtime.(*sigctxt).fs
runtime.(*sigctxt).gs
runtime.(*sigctxt).preparePanic
runtime.(*sigctxt).pushCall
runtime.(*sigctxt).r10
runtime.(*sigctxt).r11
runtime.(*sigctxt).r12
runtime.(*sigctxt).r13
runtime.(*sigctxt).r14
runtime.(*sigctxt).r15
runtime.(*sigctxt).r8
runtime.(*sigctxt).r9
runtime.(*sigctxt).rax
runtime.(*sigctxt).rbp
runtime.(*sigctxt).rbx
runtime.(*sigctxt).rcx
runtime.(*sigctxt).rdi
runtime.(*sigctxt).rdx
runtime.(*sigctxt).regs
runtime.(*sigctxt).rflags
runtime.(*sigctxt).rip
runtime.(*sigctxt).rsi
runtime.(*sigctxt).rsp
runtime.(*sigctxt).set_rip
runtime.(*sigctxt).set_rsp
runtime.(*sigctxt).set_sigaddr
runtime.(*sigctxt).set_sigcode
runtime.(*sigctxt).sigaddr
runtime.(*sigctxt).sigcode
runtime.(*sigctxt).siglr
runtime.(*sigctxt).sigpc
runtime.(*sigctxt).sigsp
runtime.(*spanSet).pop
runtime.(*spanSet).push
runtime.(*spanSet).reset
runtime.(*spanSetBlockAlloc).alloc
runtime.(*spanSetBlockAlloc).free
runtime.(*specialsIter).next
runtime.(*specialsIter).unlinkAndNext
runtime.(*specialsIter).valid
runtime.(*stackObject).setRecord
runtime.(*stackObjectRecord).gcdata
runtime.(*stackObjectRecord).ptrdata
runtime.(*stackObjectRecord).useGCProg
runtime.(*stackScanState).addObject
runtime.(*stackScanState).buildIndex
runtime.(*stackScanState).findObject
runtime.(*stackScanState).getPtr
runtime.(*stackScanState).putPtr
runtime.(*structfield).offset
runtime.(*sweepClass).clear
runtime.(*sweepClass).load
runtime.(*sweepClass).update
runtime.(*sweepLocked).sweep
runtime.(*sweepLocker).tryAcquire
runtime.(*sysMemStat).add
runtime.(*sysMemStat).load
runtime.(*timeHistogram).record
runtime.(*timespec).setNsec
runtime.(*traceAlloc).alloc
runtime.(*traceAllocBlockPtr).set
runtime.(*traceBuf).byte
runtime.(*traceBuf).varint
runtime.(*traceBufPtr).set
runtime.(*traceStack).stack
runtime.(*traceStackTable).find
runtime.(*traceStackTable).newStack
runtime.(*traceStackTable).put
runtime.(*waitReason).String
runtime.(*waitq).dequeue
runtime.(*waitq).enqueue
runtime.(*wbBuf).discard
runtime.(*wbBuf).putFast
runtime.(*wbBuf).reset
runtime.(*workbuf).checkempty
runtime.(*workbuf).checknonempty
runtime.Caller
runtime.CallersFrames
runtime.FuncForPC
runtime.GOMAXPROCS
runtime.GOROOT
runtime.Gosched
runtime.SetFinalizer
runtime.SetFinalizer.func1
runtime.SetFinalizer.func2
runtime._ExternalCode
runtime._GC
runtime._LostExternalCode
runtime._LostSIGPROFDuringAtomic64
runtime._System
runtime._VDSO
runtime.abort
runtime.acquireLockRank
runtime.acquireSudog
runtime.acquirem
runtime.acquirep
runtime.activeModules
runtime.add
runtime.add1
runtime.addAdjustedTimers
runtime.addOneOpenDeferFrame
runtime.addOneOpenDeferFrame.func1
runtime.addOneOpenDeferFrame.func1.1
runtime.addb
runtime.addfinalizer
runtime.addrRange.contains
runtime.addrRange.removeGreaterEqual
runtime.addrRange.size
runtime.addrRange.subtract
runtime.addrsToSummaryRange
runtime.addspecial
runtime.adjustSignalStack
runtime.adjustctxt
runtime.adjustdefers
runtime.adjustframe
runtime.adjustpanics
runtime.adjustpointer
runtime.adjustpointers
runtime.adjustsudogs
runtime.adjusttimers
runtime.advanceEvacuationMark
runtime.alginit
runtime.alignDown
runtime.alignUp
runtime.allGsSnapshot
runtime.allgadd
runtime.allocm
runtime.allocm.func1
runtime.allocmcache
runtime.allocmcache.func1
runtime.appendIntStr
runtime.arenaIdx.l1
runtime.arenaIdx.l2
runtime.arenaIndex
runtime.args
runtime.args
runtime.argv_index
runtime.asmcgocall
runtime.asmcgocall
runtime.asmcgocall_no_g
runtime.asminit
runtime.assertE2I
runtime.assertE2I2
runtime.assertLockHeld
runtime.assertWorldStopped
runtime.assertWorldStoppedOrLockHeld
runtime.asyncPreempt
runtime.asyncPreempt2
runtime.asyncPreempt2
runtime.atoi
runtime.atoi32
runtime.atomicAllG
runtime.atomicAllGIndex
runtime.atomicstorep
runtime.atomicwb
runtime.badPointer
runtime.badTimer
runtime.badctxt
runtime.badmcall
runtime.badmcall
runtime.badmcall2
runtime.badmcall2
runtime.badmorestackg0
runtime.badmorestackg0
runtime.badmorestackgsignal
runtime.badmorestackgsignal
runtime.badreflectcall
runtime.badreflectcall
runtime.badsignal
runtime.badsystemstack
runtime.badsystemstack
runtime.badunlockosthread
runtime.beforeIdle
runtime.bgscavenge
runtime.bgscavenge.func1
runtime.bgsweep
runtime.binarySearchTree
runtime.blockAlignSummaryRange
runtime.blockableSig
runtime.blockevent
runtime.blocksampled
runtime.bool2int
runtime.boundsError.Error
runtime.bucketEvacuated
runtime.bucketMask
runtime.bucketShift
runtime.bulkBarrierBitmap
runtime.bulkBarrierPreWrite
runtime.bulkBarrierPreWriteSrcOnly
runtime.bytes
runtime.c128equal
runtime.c128hash
runtime.c64equal
runtime.c64hash
runtime.call1024
runtime.call1048576
runtime.call1073741824
runtime.call128
runtime.call131072
runtime.call134217728
runtime.call16
runtime.call16384
runtime.call16777216
runtime.call2048
runtime.call2097152
runtime.call256
runtime.call262144
runtime.call268435456
runtime.call32
runtime.call32768
runtime.call33554432
runtime.call4096
runtime.call4194304
runtime.call512
runtime.call524288
runtime.call536870912
runtime.call64
runtime.call65536
runtime.call67108864
runtime.call8192
runtime.call8388608
runtime.callCgoSymbolizer
runtime.callers
runtime.callers.func1
runtime.canPreemptM
runtime.canpanic
runtime.cansemacquire
runtime.casGFromPreempted
runtime.casGToPreemptScan
runtime.casfrom_Gscanstatus
runtime.casgstatus
runtime.casgstatus.func1
runtime.castogscanstatus
runtime.cfuncname
runtime.cfuncnameFromNameoff
runtime.cgoCheckBits
runtime.cgoCheckMemmove
runtime.cgoCheckSliceCopy
runtime.cgoCheckTypedBlock
runtime.cgoCheckTypedBlock.func1
runtime.cgoCheckUsingType
runtime.cgoCheckWriteBarrier
runtime.cgoCheckWriteBarrier.func1
runtime.cgoContextPCs
runtime.cgoInRange
runtime.cgoIsGoPointer
runtime.cgoSigtramp
runtime.cgocall
runtime.chanbuf
runtime.chanparkcommit
runtime.chanrecv
runtime.chanrecv.func1
runtime.chanrecv1
runtime.chansend
runtime.chansend.func1
runtime.chansend1
runtime.check
runtime.check
runtime.checkASM
runtime.checkIdleGCNoP
runtime.checkRunqsNoP
runtime.checkTimeouts
runtime.checkTimers
runtime.checkTimersNoP
runtime.checkdead
runtime.checkdead.func1
runtime.checkmcount
runtime.chunkBase
runtime.chunkIdx.l1
runtime.chunkIdx.l2
runtime.chunkIndex
runtime.chunkPageIndex
runtime.clearDeletedTimers
runtime.clearpools
runtime.clobberfree
runtime.close_trampoline
runtime.closechan
runtime.closefd
runtime.closeonexec
runtime.cmpstring
runtime.concatstring2
runtime.concatstring3
runtime.concatstring4
runtime.concatstring5
runtime.concatstrings
runtime.convT
runtime.convT64
runtime.convTnoptr
runtime.convTslice
runtime.convTstring
runtime.copystack
runtime.countSub
runtime.cpuinit
runtime.cputicks
runtime.crash
runtime.createfing
runtime.debugCallCheck
runtime.debugCallCheck
runtime.debugCallCheck.func1
runtime.debugCallPanicked
runtime.debugCallV2
runtime.debugCallWrap
runtime.debugCallWrap
runtime.debugCallWrap.func1
runtime.debugCallWrap.func2
runtime.debugCallWrap1
runtime.debugCallWrap1.func1
runtime.debugCallWrap2
runtime.debugCallWrap2.func1
runtime.decoderune
runtime.deductSweepCredit
runtime.defaultMemProfileRate
runtime.deferCallSave
runtime.deferprocStack
runtime.deferreturn
runtime.deltimer
runtime.dematerializeGCProg
runtime.dieFromSignal
runtime.divRoundUp
runtime.doInit
runtime.doSigPreempt
runtime.doaddtimer
runtime.dodeltimer
runtime.dodeltimer0
runtime.dolockOSThread
runtime.dopanic_m
runtime.dounlockOSThread
runtime.dropg
runtime.dropm
runtime.duffcopy
runtime.duffzero
runtime.dumpgstatus
runtime.dumpregs
runtime.efaceOf
runtime.efaceeq
runtime.elideWrapperCalling
runtime.empty
runtime.encoderune
runtime.endCheckmarks
runtime.entersyscall
runtime.entersyscall_gcwait
runtime.entersyscall_sysmon
runtime.entersyscallblock
runtime.entersyscallblock.func1
runtime.entersyscallblock.func2
runtime.entersyscallblock_handoff
runtime.envKeyEqual
runtime.environ
runtime.eqslice
runtime.errorAddressString.Error
runtime.errorString.Error
runtime.evacuate
runtime.evacuate_fast32
runtime.evacuate_fast64
runtime.evacuate_faststr
runtime.evacuated
runtime.execute
runtime.exit
runtime.exitThread
runtime.exit_trampoline
runtime.exitsyscall
runtime.exitsyscall0
runtime.exitsyscallfast
runtime.exitsyscallfast.func1
runtime.exitsyscallfast_pidle
runtime.exitsyscallfast_reacquired
runtime.exitsyscallfast_reacquired.func1
runtime.expandCgoFrames
runtime.extendRandom
runtime.f32equal
runtime.f32hash
runtime.f64equal
runtime.f64hash
runtime.fastexprand
runtime.fastlog2
runtime.fastrand
runtime.fastrandinit
runtime.fastrandn
runtime.fatalpanic
runtime.fatalpanic.func1
runtime.fatalpanic.func2
runtime.fatalthrow
runtime.fatalthrow.func1
runtime.fcntl
runtime.fcntl_trampoline
runtime.fillAligned
runtime.fillAligned.func1
runtime.findBitRange64
runtime.findObject
runtime.findfunc
runtime.findmoduledatap
runtime.findnull
runtime.findrunnable
runtime.findsghi
runtime.finishsweep_m
runtime.float64bits
runtime.float64frombits
runtime.fmtNSAsMS
runtime.forEachG
runtime.forEachGRace
runtime.forEachP
runtime.forcegchelper
runtime.freeSomeWbufs
runtime.freeSomeWbufs.func1
runtime.freeSpecial
runtime.freeStackSpans
runtime.freedefer
runtime.freedeferfn
runtime.freedeferpanic
runtime.freemcache
runtime.freemcache.func1
runtime.freezetheworld
runtime.full
runtime.funcInfo._Func
runtime.funcInfo.entry
runtime.funcInfo.valid
runtime.funcMaxSPDelta
runtime.funcdata
runtime.funcfile
runtime.funcline
runtime.funcline1
runtime.funcname
runtime.funcnameFromNameoff
runtime.funcpkgpath
runtime.funcspdelta
runtime.gcAssistAlloc
runtime.gcAssistAlloc.func1
runtime.gcAssistAlloc1
runtime.gcBgMarkPrepare
runtime.gcBgMarkStartWorkers
runtime.gcBgMarkWorker
runtime.gcBgMarkWorker.func1
runtime.gcBgMarkWorker.func2
runtime.gcDrain
runtime.gcDrainN
runtime.gcDumpObject
runtime.gcFlushBgCredit
runtime.gcMark
runtime.gcMarkDone
runtime.gcMarkDone.func1
runtime.gcMarkDone.func1.1
runtime.gcMarkDone.func2
runtime.gcMarkDone.func3
runtime.gcMarkRootCheck
runtime.gcMarkRootCheck.func1
runtime.gcMarkRootPrepare
runtime.gcMarkRootPrepare.func1
runtime.gcMarkTermination
runtime.gcMarkTermination.func1
runtime.gcMarkTermination.func2
runtime.gcMarkTermination.func3
runtime.gcMarkTermination.func4
runtime.gcMarkTermination.func4.1
runtime.gcMarkTinyAllocs
runtime.gcMarkWorkAvailable
runtime.gcPaceScavenger
runtime.gcPaceSweeper
runtime.gcParkAssist
runtime.gcResetMarkState
runtime.gcResetMarkState.func1
runtime.gcStart
runtime.gcStart.func1
runtime.gcStart.func2
runtime.gcSweep
runtime.gcTrigger.test
runtime.gcWakeAllAssists
runtime.gcWriteBarrier
runtime.gcWriteBarrierBX
runtime.gcWriteBarrierCX
runtime.gcWriteBarrierDX
runtime.gcWriteBarrierR8
runtime.gcWriteBarrierR9
runtime.gcWriteBarrierSI
runtime.gcallers
runtime.gcd
runtime.gcenable
runtime.gcenable.func1
runtime.gcenable.func2
runtime.gcinit
runtime.gclinkptr.ptr
runtime.gcmarknewobject
runtime.gcstopm
runtime.gentraceback
runtime.getArgInfo
runtime.getArgInfoFast
runtime.getLockRank
runtime.getMCache
runtime.getPageSize
runtime.getRandomData
runtime.getStackMap
runtime.getargp
runtime.getempty
runtime.getempty.func1
runtime.getitab
runtime.getncpu
runtime.getsig
runtime.gfget
runtime.gfget.func1
runtime.gfpurge
runtime.gfput
runtime.globrunqget
runtime.globrunqput
runtime.globrunqputbatch
runtime.globrunqputhead
runtime.goPanicIndex
runtime.goPanicIndexU
runtime.goPanicSlice3Alen
runtime.goPanicSlice3AlenU
runtime.goPanicSlice3B
runtime.goPanicSlice3C
runtime.goPanicSliceAcap
runtime.goPanicSliceAcapU
runtime.goPanicSliceAlen
runtime.goPanicSliceAlenU
runtime.goPanicSliceB
runtime.goPanicSliceBU
runtime.goargs
runtime.goenvs
runtime.goenvs_unix
runtime.goexit
runtime.goexit0
runtime.goexit1
runtime.goexit1
runtime.gogetenv
runtime.gogo
runtime.gopanic
runtime.gopark
runtime.goparkunlock
runtime.gopreempt_m
runtime.goready
runtime.goready.func1
runtime.gorecover
runtime.goroutineheader
runtime.goschedImpl
runtime.gosched_m
runtime.goschedguarded
runtime.goschedguarded_m
runtime.gostartcall
runtime.gostartcallfn
runtime.gostring
runtime.gostringnocopy
runtime.gotraceback
runtime.goyield
runtime.goyield_m
runtime.greyobject
runtime.growWork
runtime.growWork_fast32
runtime.growWork_fast64
runtime.growWork_faststr
runtime.growslice
runtime.guintptr.ptr
runtime.gwrite
runtime.handoff
runtime.handoffp
runtime.hasPrefix
runtime.hashGrow
runtime.headTailIndex.head
runtime.headTailIndex.split
runtime.headTailIndex.tail
runtime.heapBits.bits
runtime.heapBits.forward
runtime.heapBits.forwardOrBoundary
runtime.heapBits.initSpan
runtime.heapBits.isPointer
runtime.heapBits.next
runtime.heapBits.nextArena
runtime.heapBitsForAddr
runtime.heapBitsSetType
runtime.heapBitsSetTypeGCProg
runtime.heapRetained
runtime.hexdumpWords
runtime.ifaceeq
runtime.inHeapOrStack
runtime.inPersistentAlloc
runtime.inVDSOPage
runtime.incidlelocked
runtime.init
runtime.init.0
runtime.init.1
runtime.init.4
runtime.init.5
runtime.init.6
runtime.initAlgAES
runtime.initsig
runtime.injectglist
runtime.injectglist.func1
runtime.int64Hash
runtime.interequal
runtime.interhash
runtime.intstring
runtime.isAbortPC
runtime.isAsyncSafePoint
runtime.isDirectIface
runtime.isEmpty
runtime.isExportedRuntime
runtime.isFinite
runtime.isInf
runtime.isNaN
runtime.isPowerOfTwo
runtime.isShrinkStackSafe
runtime.isSweepDone
runtime.isSystemGoroutine
runtime.itabAdd
runtime.itabHashFunc
runtime.itabsinit
runtime.iterate_itabs
runtime.itoa
runtime.itoaDiv
runtime.kevent
runtime.kevent_trampoline
runtime.kqueue
runtime.kqueue_trampoline
runtime.levelIndexToOffAddr
runtime.lfnodeValidate
runtime.lfstackPack
runtime.lfstackUnpack
runtime.libcCall
runtime.lock
runtime.lock2
runtime.lockInit
runtime.lockOSThread
runtime.lockRank.String
runtime.lockWithRank
runtime.lockWithRankMayAcquire
runtime.lockextra
runtime.mPark
runtime.mProf_Flush
runtime.mProf_FlushLocked
runtime.mProf_Free
runtime.mProf_Malloc
runtime.mProf_Malloc.func1
runtime.mProf_NextCycle
runtime.mReserveID
runtime.mStackIsSystemAllocated
runtime.madvise
runtime.madvise_trampoline
runtime.main
runtime.main.func1
runtime.main.func2
runtime.makeAddrRange
runtime.makeBucketArray
runtime.makeHeadTailIndex
runtime.makeSpanClass
runtime.makechan
runtime.makemap
runtime.makemap_small
runtime.makeslice
runtime.makeslicecopy
runtime.malg
runtime.malg.func1
runtime.mallocgc
runtime.mallocinit
runtime.mapaccess1_fast32
runtime.mapaccess2
runtime.mapaccess2_fast32
runtime.mapaccess2_fast64
runtime.mapaccess2_faststr
runtime.mapaccessK
runtime.mapassign
runtime.mapassign_fast32
runtime.mapassign_fast64ptr
runtime.mapassign_faststr
runtime.mapiterinit
runtime.mapiternext
runtime.markBits.isMarked
runtime.markBits.setMarked
runtime.markBits.setMarkedNonAtomic
runtime.markroot
runtime.markroot.func1
runtime.markrootBlock
runtime.markrootFreeGStacks
runtime.markrootSpans
runtime.materializeGCProg
runtime.mcall
runtime.mcommoninit
runtime.mcount
runtime.mdestroy
runtime.memclrHasPointers
runtime.memclrNoHeapPointers
runtime.memclrNoHeapPointersChunked
runtime.memequal
runtime.memequal0
runtime.memequal128
runtime.memequal16
runtime.memequal32
runtime.memequal64
runtime.memequal8
runtime.memequal_varlen
runtime.memhash
runtime.memhash128
runtime.memhash32
runtime.memhash32Fallback
runtime.memhash64
runtime.memhash64Fallback
runtime.memhashFallback
runtime.memmove
runtime.mergeSummaries
runtime.mexit
runtime.mget
runtime.minit
runtime.minitSignalMask
runtime.minitSignalStack
runtime.mix
runtime.mmap
runtime.mmap_trampoline
runtime.modtimer
runtime.moduledataverify
runtime.moduledataverify1
runtime.modulesinit
runtime.morestack
runtime.morestack_noctxt
runtime.morestackc
runtime.morestackc
runtime.moveTimers
runtime.mpreinit
runtime.mput
runtime.msigrestore
runtime.mspinning
runtime.mstart
runtime.mstart0
runtime.mstart0
runtime.mstart1
runtime.mstart_stub
runtime.mstartm0
runtime.muintptr.ptr
runtime.munmap
runtime.munmap_trampoline
runtime.name.data
runtime.name.isBlank
runtime.name.isExported
runtime.name.name
runtime.name.pkgPath
runtime.name.readvarint
runtime.name.tag
runtime.nanotime
runtime.nanotime1
runtime.nanotime_trampoline
runtime.needm
runtime.netpoll
runtime.netpollBreak
runtime.netpollGenericInit
runtime.netpollblock
runtime.netpollblockcommit
runtime.netpollcheckerr
runtime.netpollclose
runtime.netpollgoready
runtime.netpollinit
runtime.netpollinited
runtime.netpollopen
runtime.netpollready
runtime.netpollunblock
runtime.newAllocBits
runtime.newArenaMayUnlock
runtime.newBucket
runtime.newMarkBits
runtime.newSpecialsIter
runtime.newarray
runtime.newdefer
runtime.newextram
runtime.newm
runtime.newm1
runtime.newobject
runtime.newosproc
runtime.newproc
runtime.newproc
runtime.newproc.func1
runtime.newproc1
runtime.newstack
runtime.newstack
runtime.nextFreeFast
runtime.nextMarkBitArenaEpoch
runtime.nextSample
runtime.nilfunc
runtime.nilinterequal
runtime.nilinterhash
runtime.noSignalStack
runtime.nobarrierWakeTime
runtime.noescape
runtime.nonblockingPipe
runtime.noteclear
runtime.notesleep
runtime.notetsleep
runtime.notetsleep_internal
runtime.notetsleepg
runtime.notewakeup
runtime.offAddr.add
runtime.offAddr.addr
runtime.offAddr.diff
runtime.offAddr.equal
runtime.offAddr.lessEqual
runtime.offAddr.lessThan
runtime.offAddr.sub
runtime.offAddrToLevelIndex
runtime.oneNewExtraM
runtime.open
runtime.open_trampoline
runtime.osPreemptExtEnter
runtime.osPreemptExtExit
runtime.osRelax
runtime.osSetupTLS
runtime.osStackAlloc
runtime.osStackFree
runtime.osinit
runtime.osinit
runtime.osyield
runtime.osyield_no_g
runtime.overLoadFactor
runtime.pMask.clear
runtime.pMask.read
runtime.pMask.set
runtime.packPallocSum
runtime.pageIndexOf
runtime.pallocSum.end
runtime.pallocSum.max
runtime.pallocSum.start
runtime.pallocSum.unpack
runtime.panicCheck1
runtime.panicCheck2
runtime.panicIndex
runtime.panicIndexU
runtime.panicSlice3Alen
runtime.panicSlice3AlenU
runtime.panicSlice3B
runtime.panicSlice3C
runtime.panicSliceAcap
runtime.panicSliceAcapU
runtime.panicSliceAlen
runtime.panicSliceAlenU
runtime.panicSliceB
runtime.panicSliceBU
runtime.panicdivide
runtime.panicdottypeE
runtime.panicdottypeI
runtime.panicfloat
runtime.panicmakeslicecap
runtime.panicmakeslicelen
runtime.panicmem
runtime.panicmemAddr
runtime.panicoverflow
runtime.panicshift
runtime.panicwrap
runtime.park_m
runtime.parkunlock_c
runtime.parsedebugvars
runtime.pcdatastart
runtime.pcdatavalue
runtime.pcdatavalue1
runtime.pcdatavalue2
runtime.pcvalue
runtime.pcvalueCacheKey
runtime.persistentalloc
runtime.persistentalloc.func1
runtime.persistentalloc1
runtime.pidleget
runtime.pidleput
runtime.pipe
runtime.pipe_trampoline
runtime.plainError.Error
runtime.pollFractionalWorkerExit
runtime.pollInfo.closing
runtime.pollInfo.eventErr
runtime.pollInfo.expiredReadDeadline
runtime.pollInfo.expiredWriteDeadline
runtime.pollWork
runtime.preemptM
runtime.preemptPark
runtime.preemptall
runtime.preemptone
runtime.prepareFreeWorkbufs
runtime.preprintpanics
runtime.preprintpanics.func1
runtime.printAncestorTraceback
runtime.printAncestorTracebackFuncInfo
runtime.printArgs
runtime.printArgs.func1
runtime.printArgs.func2
runtime.printArgs.func3
runtime.printCgoTraceback
runtime.printDebugLog
runtime.printOneCgoTraceback
runtime.printScavTrace
runtime.printany
runtime.printanycustomtype
runtime.printbool
runtime.printcomplex
runtime.printcreatedby
runtime.printcreatedby1
runtime.printfloat
runtime.printhex
runtime.printint
runtime.printlock
runtime.printnl
runtime.printpanics
runtime.printpointer
runtime.printslice
runtime.printsp
runtime.printstring
runtime.printuint
runtime.printuintptr
runtime.printunlock
runtime.procPin
runtime.procUnpin
runtime.procresize
runtime.procyield
runtime.profIndex.addCountsAndClearFlags
runtime.profIndex.dataCount
runtime.profIndex.tagCount
runtime.profilealloc
runtime.progToPointerMask
runtime.pthread_attr_getstacksize
runtime.pthread_attr_getstacksize_trampoline
runtime.pthread_attr_init
runtime.pthread_attr_init_trampoline
runtime.pthread_attr_setdetachstate
runtime.pthread_attr_setdetachstate_trampoline
runtime.pthread_cond_init
runtime.pthread_cond_init_trampoline
runtime.pthread_cond_signal
runtime.pthread_cond_signal_trampoline
runtime.pthread_cond_timedwait_relative_np
runtime.pthread_cond_timedwait_relative_np_trampoline
runtime.pthread_cond_wait
runtime.pthread_cond_wait_trampoline
runtime.pthread_create
runtime.pthread_create_trampoline
runtime.pthread_kill
runtime.pthread_kill_trampoline
runtime.pthread_mutex_init
runtime.pthread_mutex_init_trampoline
runtime.pthread_mutex_lock
runtime.pthread_mutex_lock_trampoline
runtime.pthread_mutex_unlock
runtime.pthread_mutex_unlock_trampoline
runtime.pthread_self
runtime.pthread_self_trampoline
runtime.publicationBarrier
runtime.puintptr.ptr
runtime.putempty
runtime.putfull
runtime.queuefinalizer
runtime.r4
runtime.r8
runtime.raise
runtime.raise_trampoline
runtime.raisebadsignal
runtime.raiseproc
runtime.raiseproc_trampoline
runtime.rawbyteslice
runtime.rawstring
runtime.rawstringtmp
runtime.read
runtime.readGOGC
runtime.readUnaligned32
runtime.readUnaligned64
runtime.read_trampoline
runtime.readgstatus
runtime.readvarint
runtime.readvarintUnsafe
runtime.ready
runtime.readyForScavenger
runtime.readyWithTime
runtime.recordForPanic
runtime.recordspan
runtime.recovery
runtime.recv
runtime.recvDirect
runtime.reentersyscall
runtime.reentersyscall.func1
runtime.reflectOffsLock
runtime.reflectOffsUnlock
runtime.reflectcall
runtime.reflectcall
runtime.reflectcallmove
runtime.reflectcallmove
runtime.releaseLockRank
runtime.releaseSudog
runtime.releasem
runtime.releasep
runtime.removefinalizer
runtime.removespecial
runtime.resetspinning
runtime.resettimer
runtime.resolveNameOff
runtime.resolveTypeOff
runtime.restoreGsignalStack
runtime.resumeG
runtime.retake
runtime.return0
runtime.round2
runtime.roundupsize
runtime.rt0_go
runtime.runGCProg
runtime.runOneTimer
runtime.runOpenDeferFrame
runtime.runSafePointFn
runtime.runfinq
runtime.runqdrain
runtime.runqempty
runtime.runqget
runtime.runqgrab
runtime.runqput
runtime.runqputbatch
runtime.runqputslow
runtime.runqsteal
runtime.runtimer
runtime.save
runtime.saveAncestors
runtime.saveblockevent
runtime.scanConservative
runtime.scanblock
runtime.scanframeworker
runtime.scanobject
runtime.scanstack
runtime.scanstack.func1
runtime.scavengeSleep
runtime.schedEnableUser
runtime.schedEnabled
runtime.schedinit
runtime.schedinit
runtime.schedtrace
runtime.schedtrace.func1
runtime.schedule
runtime.semacquire
runtime.semacquire1
runtime.semacreate
runtime.semasleep
runtime.semawakeup
runtime.semrelease
runtime.semrelease1
runtime.semroot
runtime.send
runtime.sendDirect
runtime.setCheckmark
runtime.setGCPhase
runtime.setGNoWB
runtime.setGsignalStack
runtime.setMNoWB
runtime.setNonblock
runtime.setSignalstackSP
runtime.setThreadCPUProfiler
runtime.setThreadCPUProfilerHz
runtime.setg
runtime.setprofilebucket
runtime.setsig
runtime.setsigstack
runtime.settls
runtime.shade
runtime.shouldPushSigpanic
runtime.showframe
runtime.showfuncinfo
runtime.shrinkstack
runtime.siftdownTimer
runtime.siftupTimer
runtime.sigFetchG
runtime.sigInitIgnored
runtime.sigInstallGoHandler
runtime.sigNotOnStack
runtime.sigNoteWakeup
runtime.sigaction
runtime.sigaction_trampoline
runtime.sigaddset
runtime.sigaltstack
runtime.sigaltstack_trampoline
runtime.sigblock
runtime.sigdelset
runtime.sigfwd
runtime.sigfwdgo
runtime.sighandler
runtime.signalDuringFork
runtime.signalM
runtime.signalstack
runtime.signame
runtime.sigpanic
runtime.sigpanic0
runtime.sigpipe
runtime.sigprocmask
runtime.sigprocmask_trampoline
runtime.sigprof
runtime.sigprofNonGo
runtime.sigprofNonGo
runtime.sigprofNonGoPC
runtime.sigprofNonGoWrapper
runtime.sigsave
runtime.sigsend
runtime.sigtramp
runtime.sigtrampgo
runtime.sigtrampgo
runtime.slicebytetostring
runtime.spanAllocType.manual
runtime.spanClass.noscan
runtime.spanClass.sizeclass
runtime.spanHasNoSpecials
runtime.spanHasSpecials
runtime.spanOf
runtime.spanOfHeap
runtime.spanOfUnchecked
runtime.spillArgs
runtime.stackalloc
runtime.stackcache_clear
runtime.stackcacherefill
runtime.stackcacherelease
runtime.stackfree
runtime.stackinit
runtime.stacklog2
runtime.stackmapdata
runtime.stackpoolalloc
runtime.stackpoolfree
runtime.startCheckmarks
runtime.startPCforTrace
runtime.startTemplateThread
runtime.startTheWorld
runtime.startTheWorld.func1
runtime.startTheWorldGC
runtime.startTheWorldWithSema
runtime.startlockedm
runtime.startm
runtime.startpanic_m
runtime.stealWork
runtime.step
runtime.stkbucket
runtime.stkobjinit
runtime.stopTheWorld
runtime.stopTheWorld.func1
runtime.stopTheWorldGC
runtime.stopTheWorldWithSema
runtime.stoplockedm
runtime.stopm
runtime.strequal
runtime.strhash
runtime.strhashFallback
runtime.stringDataOnStack
runtime.stringStructOf
runtime.stringtoslicebyte
runtime.subtract1
runtime.subtractb
runtime.suspendG
runtime.sweepClass.split
runtime.sweepone
runtime.sweepone.func1
runtime.syncadjustsudogs
runtime.sysAlloc
runtime.sysFault
runtime.sysFree
runtime.sysMap
runtime.sysReserve
runtime.sysReserveAligned
runtime.sysUnused
runtime.sysUsed
runtime.sysargs
runtime.syscall
runtime.syscall6X
runtime.syscallX
runtime.sysctl
runtime.sysctl_trampoline
runtime.sysmon
runtime.systemstack
runtime.systemstack_switch
runtime.templateThread
runtime.testAtomic64
runtime.throw
runtime.throw.func1
runtime.timeSleepUntil
runtime.timediv
runtime.tooManyOverflowBuckets
runtime.tophash
runtime.traceAcquireBuffer
runtime.traceAllocBlockPtr.ptr
runtime.traceBufPtr.ptr
runtime.traceBufPtrOf
runtime.traceEvent
runtime.traceEventLocked
runtime.traceFlush
runtime.traceFullQueue
runtime.traceGCDone
runtime.traceGCMarkAssistDone
runtime.traceGCMarkAssistStart
runtime.traceGCSTWDone
runtime.traceGCSTWStart
runtime.traceGCStart
runtime.traceGCSweepDone
runtime.traceGCSweepSpan
runtime.traceGCSweepStart
runtime.traceGoCreate
runtime.traceGoEnd
runtime.traceGoPark
runtime.traceGoPreempt
runtime.traceGoSched
runtime.traceGoStart
runtime.traceGoSysBlock
runtime.traceGoSysCall
runtime.traceGoSysExit
runtime.traceGoUnpark
runtime.traceGomaxprocs
runtime.traceHeapAlloc
runtime.traceHeapGoal
runtime.traceProcFree
runtime.traceProcStart
runtime.traceProcStop
runtime.traceReader
runtime.traceReleaseBuffer
runtime.traceStackID
runtime.traceStackPtr.ptr
runtime.tracealloc
runtime.tracealloc.func1
runtime.traceback
runtime.traceback1
runtime.tracebackCgoContext
runtime.tracebackHexdump
runtime.tracebackHexdump.func1
runtime.tracebackothers
runtime.tracebackothers.func1
runtime.tracebacktrap
runtime.tracefree
runtime.tracefree.func1
runtime.tracegc
runtime.trygetfull
runtime.typeBitsBulkBarrier
runtime.typedmemclr
runtime.typedmemmove
runtime.typedslicecopy
runtime.typehash
runtime.typelinksinit
runtime.typesEqual
runtime.unblocksig
runtime.unlock
runtime.unlock2
runtime.unlockOSThread
runtime.unlockWithRank
runtime.unlockextra
runtime.unminit
runtime.unminitSignals
runtime.unreachableMethod
runtime.unspillArgs
runtime.updateTimer0When
runtime.updateTimerModifiedEarliest
runtime.updateTimerPMask
runtime.usesLibcall
runtime.usleep
runtime.usleep_no_g
runtime.usleep_trampoline
runtime.validSIGPROF
runtime.waitReason.String
runtime.wakeNetPoller
runtime.wakeScavenger
runtime.wakefing
runtime.wakep
runtime.walltime
runtime.walltime_trampoline
runtime.wantAsyncPreempt
runtime.wbBufFlush
runtime.wbBufFlush
runtime.wbBufFlush.func1
runtime.wbBufFlush1
runtime.wirep
runtime.worldStarted
runtime.worldStopped
runtime.write
runtime.write
runtime.write1
runtime.writeErr
runtime.write_trampoline
runtime/debug.SetTraceback
runtime/internal/atomic.(*Float64).Load
runtime/internal/atomic.(*Float64).Store
runtime/internal/atomic.(*Int32).Load
runtime/internal/atomic.(*Int32).Store
runtime/internal/atomic.(*Int64).Add
runtime/internal/atomic.(*Int64).Load
runtime/internal/atomic.(*Int64).Store
runtime/internal/atomic.(*Uint32).CompareAndSwap
runtime/internal/atomic.(*Uint32).Load
runtime/internal/atomic.(*Uint32).Store
runtime/internal/atomic.(*Uint64).Add
runtime/internal/atomic.(*Uint64).Load
runtime/internal/atomic.(*Uint64).Store
runtime/internal/atomic.(*Uintptr).Add
runtime/internal/atomic.(*Uintptr).CompareAndSwap
runtime/internal/atomic.(*Uintptr).Load
runtime/internal/atomic.(*Uintptr).Store
runtime/internal/atomic.(*Uintptr).Swap
runtime/internal/sys.LeadingZeros64
runtime/internal/sys.OnesCount64
setg_gcc
sort.Stable
sort.insertionSort
sort.rotate
sort.stable
sort.swapRange
sort.symMerge
strconv.(*decimal).Assign
strconv.(*decimal).Round
strconv.(*decimal).RoundDown
strconv.(*decimal).RoundUp
strconv.(*decimal).Shift
strconv.AppendFloat
strconv.AppendQuote
strconv.AppendQuoteRune
strconv.AppendQuoteRuneToASCII
strconv.AppendQuoteToASCII
strconv.CanBackquote
strconv.FormatInt
strconv.IsPrint
strconv.Itoa
strconv.appendEscapedRune
strconv.appendQuotedRuneWith
strconv.appendQuotedWith
strconv.bigFtoa
strconv.bsearch16
strconv.bsearch32
strconv.computeBounds
strconv.divisibleByPower5
strconv.divmod1e9
strconv.fmtB
strconv.fmtE
strconv.fmtF
strconv.fmtX
strconv.formatBits
strconv.formatDecimal
strconv.formatDigits
strconv.genericFtoa
strconv.init
strconv.isInGraphicList
strconv.isPowerOfTwo
strconv.leftShift
strconv.lower
strconv.max
strconv.min
strconv.mulByLog10Log2
strconv.mulByLog2Log10
strconv.mult128bitPow10
strconv.mult64bitPow10
strconv.prefixIsLessThan
strconv.rightShift
strconv.roundShortest
strconv.ryuDigits
strconv.ryuDigits32
strconv.ryuFtoaFixed32
strconv.ryuFtoaFixed64
strconv.ryuFtoaShortest
strconv.shouldRoundUp
strconv.small
strconv.trim
sync.(*Map).Load
sync.(*Map).LoadOrStore
sync.(*Map).dirtyLocked
sync.(*Map).missLocked
sync.(*Mutex).Lock
sync.(*Mutex).Unlock
sync.(*Mutex).lockSlow
sync.(*Mutex).unlockSlow
sync.(*Once).Do
sync.(*Once).doSlow
sync.(*Once).doSlow.func1
sync.(*Once).doSlow.func2
sync.(*Pool).Get
sync.(*Pool).Put
sync.(*Pool).getSlow
sync.(*Pool).pin
sync.(*Pool).pinSlow
sync.(*Pool).pinSlow.func1
sync.(*RWMutex).RLock
sync.(*RWMutex).RUnlock
sync.(*RWMutex).rUnlockSlow
sync.(*entry).load
sync.(*entry).tryExpungeLocked
sync.(*entry).tryLoadOrStore
sync.(*entry).unexpungeLocked
sync.(*poolChain).popHead
sync.(*poolChain).popTail
sync.(*poolChain).pushHead
sync.(*poolDequeue).pack
sync.(*poolDequeue).popHead
sync.(*poolDequeue).popTail
sync.(*poolDequeue).pushHead
sync.(*poolDequeue).unpack
sync.event
sync.indexLocal
sync.init
sync.init.0
sync.init.1
sync.loadPoolChainElt
sync.newEntry
sync.poolCleanup
sync.runtime_SemacquireMutex
sync.runtime_Semrelease
sync.runtime_canSpin
sync.runtime_doSpin
sync.runtime_nanotime
sync.runtime_notifyListCheck
sync.runtime_procPin
sync.runtime_procUnpin
sync.runtime_registerPoolCleanup
sync.storePoolChainElt
sync.throw
sync/atomic.(*Value).Load
sync/atomic.(*Value).Store
sync/atomic.CompareAndSwapPointer
sync/atomic.CompareAndSwapUintptr
sync/atomic.StorePointer
sync/atomic.StoreUint32
sync/atomic.StoreUintptr
sync/atomic.runtime_procPin
sync/atomic.runtime_procUnpin
syscall.(*Errno).Error
syscall.BytePtrFromString
syscall.ByteSliceFromString
syscall.Close
syscall.Errno.Error
syscall.Fstat
syscall.Getenv
syscall.Getenv.func1
syscall.Getwd
syscall.Open
syscall.Read
syscall.Seek
syscall.SetNonblock
syscall.Stat
syscall.Write
syscall.clen
syscall.closedir
syscall.copyenv
syscall.errnoErr
syscall.execve
syscall.fcntl
syscall.getcwd
syscall.init
syscall.init.0
syscall.libc_close_trampoline
syscall.libc_closedir_trampoline
syscall.libc_execve_trampoline
syscall.libc_fcntl_trampoline
syscall.libc_fstat64_trampoline
syscall.libc_getcwd_trampoline
syscall.libc_lseek_trampoline
syscall.libc_mmap_trampoline
syscall.libc_munmap_trampoline
syscall.libc_open_trampoline
syscall.libc_read_trampoline
syscall.libc_stat64_trampoline
syscall.libc_write_trampoline
syscall.mmap
syscall.munmap
syscall.rawSyscall
syscall.read
syscall.rsaAlignOf
syscall.runtime_envs
syscall.syscall
syscall.syscall6X
syscall.syscallX
syscall.write
time.(*Location).String
time.(*Location).firstZoneUsed
time.(*Location).get
time.(*Location).lookup
time.(*Location).lookupFirstZone
time.(*Time).GoString
time.(*Time).String
time.(*Time).nsec
time.(*Time).sec
time.(*Time).unixSec
time.(*dataIO).big4
time.(*dataIO).big8
time.(*dataIO).byte
time.(*dataIO).read
time.(*dataIO).rest
time.(*fileSizeError).Error
time.LoadLocationFromTZData
time.Month.String
time.Time.AppendFormat
time.Time.Day
time.Time.Format
time.Time.GoString
time.Time.Hour
time.Time.Location
time.Time.Minute
time.Time.Month
time.Time.Nanosecond
time.Time.Second
time.Time.String
time.Time.Year
time.Time.abs
time.Time.date
time.Time.locabs
time.Unix
time.Weekday.String
time.absClock
time.absDate
time.absWeekday
time.appendInt
time.byteString
time.closefd
time.daysIn
time.daysSinceEpoch
time.digitsLen
time.fileSizeError.Error
time.findZone
time.fmtInt
time.formatNano
time.get2
time.get4
time.init
time.initLocal
time.isDigit
time.isLeap
time.loadLocation
time.loadTzinfo
time.loadTzinfoFromDirOrZip
time.loadTzinfoFromZip
time.loadTzinfoFromZip.func1
time.nextStdChunk
time.now
time.open
time.preadn
time.quote
time.read
time.readFile
time.readFile.func1
time.resetTimer
time.separator
time.startsWithLowerCase
time.stdFracSecond
time.stopTimer
time.tzruleTime
time.tzset
time.tzsetName
time.tzsetNum
time.tzsetOffset
time.tzsetRule
time.unixTime
type..eq.[15]internal/cpu.option
type..eq.[2]runtime.Frame
type..eq.fmt.fmt
type..eq.internal/abi.RegArgs
type..eq.internal/cpu.option
type..eq.internal/poll.FD
type..eq.internal/reflectlite.uncommonType
type..eq.io/fs.PathError
type..eq.os.SyscallError
type..eq.os.file
type..eq.os.fileStat
type..eq.reflect.MapIter
type..eq.reflect.Method
type..eq.reflect.ValueError
type..eq.reflect.hiter
type..eq.reflect.makeFuncCtxt
type..eq.reflect.methodValue
type..eq.reflect.uncommonType
type..eq.runtime.Frame
type..eq.runtime.TypeAssertionError
type..eq.runtime._func
type..eq.runtime._panic
type..eq.runtime.bitvector
type..eq.runtime.boundsError
type..eq.runtime.errorAddressString
type..eq.runtime.funcinl
type..eq.runtime.gcWork
type..eq.runtime.hchan
type..eq.runtime.itab
type..eq.runtime.mOS
type..eq.runtime.mcache
type..eq.runtime.modulehash
type..eq.runtime.mspan
type..eq.runtime.special
type..eq.runtime.sudog
type..eq.runtime.sysmontick
type..eq.struct { runtime.gList; runtime.n int32 }
type..eq.sync.poolLocal
type..eq.sync.poolLocalInternal
type..eq.time.zone
type..eq.time.zoneTrans
unicode.init
unicode/utf8.DecodeRune
unicode/utf8.DecodeRuneInString
unicode/utf8.EncodeRune
unicode/utf8.RuneCount
unicode/utf8.RuneCountInString
unicode/utf8.RuneLen
unicode/utf8.ValidRune
(dlv) funcs /main/
(dlv) funcs /test/
(dlv) funcs test
internal/testlog.Getenv
internal/testlog.Logger
runtime.gcTrigger.test
runtime.testAtomic64
strconv.roundShortest
strconv.ryuFtoaShortest
(dlv) funcs main
main.CanEnd
main.getMaxofSmaller
main.getMinOfGreater
main.main
main.oddEvenJumps
runtime.main
runtime.main.func1
runtime.main.func2
(dlv) break /main.*/
Breakpoint 1 set at 0x1036446 for runtime.main.func1() /usr/local/go/src/runtime/proc.go:170
Breakpoint 2 set at 0x103648a for runtime.main() /usr/local/go/src/runtime/proc.go:145
Breakpoint 3 set at 0x1036786 for runtime.main.func2() /usr/local/go/src/runtime/proc.go:203
Breakpoint 4 set at 0x10ad0ca for main.oddEvenJumps() ./main.go:8
Breakpoint 5 set at 0x10ad20a for main.CanEnd() ./main.go:19
Breakpoint 6 set at 0x10ad3a0 for main.getMinOfGreater() ./main.go:40
Breakpoint 7 set at 0x10ad4e0 for main.getMaxofSmaller() ./main.go:52
Breakpoint 8 set at 0x10ad62f for main.main() ./main.go:65
(dlv) c
> runtime.main() /usr/local/go/src/runtime/proc.go:145 (hits goroutine(1):1 total:1) (PC: 0x103648a)
Warning: debugging optimized function
   140:	
   141:	// Value to use for signal mask for newly created M's.
   142:	var initSigmask sigset
   143:	
   144:	// The main goroutine.
=> 145:	func main() {
   146:		g := getg()
   147:	
   148:		// Racectx of m0->g0 is used only as the parent of the main goroutine.
   149:		// It must not be used for anything else.
   150:		g.m.g0.racectx = 0
(dlv) c
> runtime.main.func1() /usr/local/go/src/runtime/proc.go:170 (hits goroutine(1):1 total:1) (PC: 0x1036446)
Warning: debugging optimized function
   165:	
   166:		// Allow newproc to start new Ms.
   167:		mainStarted = true
   168:	
   169:		if GOARCH != "wasm" { // no threads on wasm yet, so no sysmon
=> 170:			systemstack(func() {
   171:				newm(sysmon, nil, -1)
   172:			})
   173:		}
   174:	
   175:		// Lock the main goroutine onto this, the main OS thread,
(dlv) c
> main.main() ./main.go:65 (hits goroutine(1):1 total:1) (PC: 0x10ad62f)
    60:	    }
    61:	    return next
    62:	
    63:	}
    64:	
=>  65:	func main (){
    66:		fmt.Println(oddEvenJumps([]int{10,13,12,14,15}))
    67:	}
(dlv) n
> main.main() ./main.go:66 (PC: 0x10ad646)
    61:	    return next
    62:	
    63:	}
    64:	
    65:	func main (){
=>  66:		fmt.Println(oddEvenJumps([]int{10,13,12,14,15}))
    67:	}
(dlv) c
> main.oddEvenJumps() ./main.go:8 (hits goroutine(1):1 total:1) (PC: 0x10ad0ca)
     3:	import(
     4:		"math"
     5:		"fmt"
     6:	)
     7:	
=>   8:	func oddEvenJumps(arr []int) int {
     9:	    jmps := 0    
    10:	    for i,val := range arr {
    11:	        if CanEnd(arr,i+1, val) {
    12:	            jmps++
    13:	        }
(dlv) n
> main.oddEvenJumps() ./main.go:9 (PC: 0x10ad0f9)
     4:		"math"
     5:		"fmt"
     6:	)
     7:	
     8:	func oddEvenJumps(arr []int) int {
=>   9:	    jmps := 0    
    10:	    for i,val := range arr {
    11:	        if CanEnd(arr,i+1, val) {
    12:	            jmps++
    13:	        }
    14:	    }
(dlv) n
> main.oddEvenJumps() ./main.go:10 (PC: 0x10ad102)
     5:		"fmt"
     6:	)
     7:	
     8:	func oddEvenJumps(arr []int) int {
     9:	    jmps := 0    
=>  10:	    for i,val := range arr {
    11:	        if CanEnd(arr,i+1, val) {
    12:	            jmps++
    13:	        }
    14:	    }
    15:	    
(dlv) n
> main.oddEvenJumps() ./main.go:11 (PC: 0x10ad16c)
     6:	)
     7:	
     8:	func oddEvenJumps(arr []int) int {
     9:	    jmps := 0    
    10:	    for i,val := range arr {
=>  11:	        if CanEnd(arr,i+1, val) {
    12:	            jmps++
    13:	        }
    14:	    }
    15:	    
    16:	    return jmps 
(dlv) n
> main.CanEnd() ./main.go:19 (hits goroutine(1):1 total:1) (PC: 0x10ad20a)
    14:	    }
    15:	    
    16:	    return jmps 
    17:	}
    18:	
=>  19:	func CanEnd(arr []int,startIdx, val int) bool {
    20:	    jmps := 1
    21:	    end:=len(arr)
    22:	    
    23:	    for startIdx<end{
    24:	        if jmps % 2 == 1 {
(dlv) n
> main.CanEnd() ./main.go:20 (PC: 0x10ad239)
    15:	    
    16:	    return jmps 
    17:	}
    18:	
    19:	func CanEnd(arr []int,startIdx, val int) bool {
=>  20:	    jmps := 1
    21:	    end:=len(arr)
    22:	    
    23:	    for startIdx<end{
    24:	        if jmps % 2 == 1 {
    25:	            startIdx = getMinOfGreater (arr , startIdx , arr[startIdx])
(dlv) n
> main.CanEnd() ./main.go:21 (PC: 0x10ad242)
    16:	    return jmps 
    17:	}
    18:	
    19:	func CanEnd(arr []int,startIdx, val int) bool {
    20:	    jmps := 1
=>  21:	    end:=len(arr)
    22:	    
    23:	    for startIdx<end{
    24:	        if jmps % 2 == 1 {
    25:	            startIdx = getMinOfGreater (arr , startIdx , arr[startIdx])
    26:	            if startIdx == -1{
(dlv) n
> main.CanEnd() ./main.go:23 (PC: 0x10ad24e)
    18:	
    19:	func CanEnd(arr []int,startIdx, val int) bool {
    20:	    jmps := 1
    21:	    end:=len(arr)
    22:	    
=>  23:	    for startIdx<end{
    24:	        if jmps % 2 == 1 {
    25:	            startIdx = getMinOfGreater (arr , startIdx , arr[startIdx])
    26:	            if startIdx == -1{
    27:	                break
    28:	            }
(dlv) n
> main.CanEnd() ./main.go:24 (PC: 0x10ad25f)
    19:	func CanEnd(arr []int,startIdx, val int) bool {
    20:	    jmps := 1
    21:	    end:=len(arr)
    22:	    
    23:	    for startIdx<end{
=>  24:	        if jmps % 2 == 1 {
    25:	            startIdx = getMinOfGreater (arr , startIdx , arr[startIdx])
    26:	            if startIdx == -1{
    27:	                break
    28:	            }
    29:	        }else{
(dlv) n
> main.CanEnd() ./main.go:25 (PC: 0x10ad27f)
    20:	    jmps := 1
    21:	    end:=len(arr)
    22:	    
    23:	    for startIdx<end{
    24:	        if jmps % 2 == 1 {
=>  25:	            startIdx = getMinOfGreater (arr , startIdx , arr[startIdx])
    26:	            if startIdx == -1{
    27:	                break
    28:	            }
    29:	        }else{
    30:	            startIdx = getMaxofSmaller (arr , startIdx , arr[startIdx])
(dlv) c
> main.getMinOfGreater() ./main.go:40 (hits goroutine(1):1 total:1) (PC: 0x10ad3a0)
    35:	        jmps++
    36:	    }
    37:	        return startIdx == end -1 
    38:	}
    39:	
=>  40:	func getMinOfGreater (arr []int, startIdx , val int) int {
    41:	    min := math.MaxInt
    42:	    next:=-1
    43:	    for i:=startIdx;i < len(arr);i++ {
    44:	        if arr[i]>val && arr[i]<min{
    45:	            min = arr[i]
(dlv) c
> main.getMaxofSmaller() ./main.go:52 (hits goroutine(1):1 total:1) (PC: 0x10ad4e0)
    47:	        }
    48:	    }
    49:	    return next
    50:	}
    51:	
=>  52:	func getMaxofSmaller (arr []int, startIdx , val int) int {
    53:	    max := 0
    54:	        next:=-1
    55:	    for i:=startIdx;i < len(arr);i++ {
    56:	        if arr[i]<val && arr[i]>max{
    57:	            max = arr[i]
(dlv) bp
Breakpoint runtime-fatal-throw (enabled) at 0x1033f60 for runtime.throw() /usr/local/go/src/runtime/panic.go:982 (0)
Breakpoint unrecovered-panic (enabled) at 0x1034320 for runtime.fatalpanic() /usr/local/go/src/runtime/panic.go:1065 (0)
	print runtime.curg._panic.arg
Breakpoint 1 (enabled) at 0x1036446 for runtime.main.func1() /usr/local/go/src/runtime/proc.go:170 (1)
Breakpoint 2 (enabled) at 0x103648a for runtime.main() /usr/local/go/src/runtime/proc.go:145 (1)
Breakpoint 3 (enabled) at 0x1036786 for runtime.main.func2() /usr/local/go/src/runtime/proc.go:203 (0)
Breakpoint 4 (enabled) at 0x10ad0ca for main.oddEvenJumps() ./main.go:8 (1)
Breakpoint 5 (enabled) at 0x10ad20a for main.CanEnd() ./main.go:19 (1)
Breakpoint 6 (enabled) at 0x10ad3a0 for main.getMinOfGreater() ./main.go:40 (1)
Breakpoint 7 (enabled) at 0x10ad4e0 for main.getMaxofSmaller() ./main.go:52 (1)
Breakpoint 8 (enabled) at 0x10ad62f for main.main() ./main.go:65 (1)
(dlv) n
> main.getMaxofSmaller() ./main.go:53 (PC: 0x10ad510)
    48:	    }
    49:	    return next
    50:	}
    51:	
    52:	func getMaxofSmaller (arr []int, startIdx , val int) int {
=>  53:	    max := 0
    54:	        next:=-1
    55:	    for i:=startIdx;i < len(arr);i++ {
    56:	        if arr[i]<val && arr[i]>max{
    57:	            max = arr[i]
    58:	            next = i
(dlv) n
> main.getMaxofSmaller() ./main.go:54 (PC: 0x10ad519)
    49:	    return next
    50:	}
    51:	
    52:	func getMaxofSmaller (arr []int, startIdx , val int) int {
    53:	    max := 0
=>  54:	        next:=-1
    55:	    for i:=startIdx;i < len(arr);i++ {
    56:	        if arr[i]<val && arr[i]>max{
    57:	            max = arr[i]
    58:	            next = i
    59:	        }
(dlv) n
> main.getMaxofSmaller() ./main.go:55 (PC: 0x10ad522)
    50:	}
    51:	
    52:	func getMaxofSmaller (arr []int, startIdx , val int) int {
    53:	    max := 0
    54:	        next:=-1
=>  55:	    for i:=startIdx;i < len(arr);i++ {
    56:	        if arr[i]<val && arr[i]>max{
    57:	            max = arr[i]
    58:	            next = i
    59:	        }
    60:	    }
(dlv) n
> main.getMaxofSmaller() ./main.go:56 (PC: 0x10ad545)
    51:	
    52:	func getMaxofSmaller (arr []int, startIdx , val int) int {
    53:	    max := 0
    54:	        next:=-1
    55:	    for i:=startIdx;i < len(arr);i++ {
=>  56:	        if arr[i]<val && arr[i]>max{
    57:	            max = arr[i]
    58:	            next = i
    59:	        }
    60:	    }
    61:	    return next
(dlv) n
> main.getMaxofSmaller() ./main.go:55 (PC: 0x10ad5d5)
    50:	}
    51:	
    52:	func getMaxofSmaller (arr []int, startIdx , val int) int {
    53:	    max := 0
    54:	        next:=-1
=>  55:	    for i:=startIdx;i < len(arr);i++ {
    56:	        if arr[i]<val && arr[i]>max{
    57:	            max = arr[i]
    58:	            next = i
    59:	        }
    60:	    }
(dlv) n
> main.getMaxofSmaller() ./main.go:56 (PC: 0x10ad545)
    51:	
    52:	func getMaxofSmaller (arr []int, startIdx , val int) int {
    53:	    max := 0
    54:	        next:=-1
    55:	    for i:=startIdx;i < len(arr);i++ {
=>  56:	        if arr[i]<val && arr[i]>max{
    57:	            max = arr[i]
    58:	            next = i
    59:	        }
    60:	    }
    61:	    return next
(dlv) n
> main.getMaxofSmaller() ./main.go:55 (PC: 0x10ad5d5)
    50:	}
    51:	
    52:	func getMaxofSmaller (arr []int, startIdx , val int) int {
    53:	    max := 0
    54:	        next:=-1
=>  55:	    for i:=startIdx;i < len(arr);i++ {
    56:	        if arr[i]<val && arr[i]>max{
    57:	            max = arr[i]
    58:	            next = i
    59:	        }
    60:	    }
(dlv) n
> main.getMaxofSmaller() ./main.go:61 (PC: 0x10ad5eb)
    56:	        if arr[i]<val && arr[i]>max{
    57:	            max = arr[i]
    58:	            next = i
    59:	        }
    60:	    }
=>  61:	    return next
    62:	
    63:	}
    64:	
    65:	func main (){
    66:		fmt.Println(oddEvenJumps([]int{10,13,12,14,15}))
(dlv) print next
-1
(dlv) n
> main.CanEnd() ./main.go:30 (PC: 0x10ad30c)
Values returned:
	~r0: -1

    25:	            startIdx = getMinOfGreater (arr , startIdx , arr[startIdx])
    26:	            if startIdx == -1{
    27:	                break
    28:	            }
    29:	        }else{
=>  30:	            startIdx = getMaxofSmaller (arr , startIdx , arr[startIdx])
    31:	            if startIdx == -1{
    32:	                break
    33:	            }            
    34:	        }
    35:	        jmps++
(dlv) n
> main.CanEnd() ./main.go:31 (PC: 0x10ad311)
    26:	            if startIdx == -1{
    27:	                break
    28:	            }
    29:	        }else{
    30:	            startIdx = getMaxofSmaller (arr , startIdx , arr[startIdx])
=>  31:	            if startIdx == -1{
    32:	                break
    33:	            }            
    34:	        }
    35:	        jmps++
    36:	    }
(dlv) n
> main.CanEnd() ./main.go:32 (PC: 0x10ad319)
    27:	                break
    28:	            }
    29:	        }else{
    30:	            startIdx = getMaxofSmaller (arr , startIdx , arr[startIdx])
    31:	            if startIdx == -1{
=>  32:	                break
    33:	            }            
    34:	        }
    35:	        jmps++
    36:	    }
    37:	        return startIdx == end -1 
(dlv) n
> main.CanEnd() ./main.go:37 (PC: 0x10ad333)
    32:	                break
    33:	            }            
    34:	        }
    35:	        jmps++
    36:	    }
=>  37:	        return startIdx == end -1 
    38:	}
    39:	
    40:	func getMinOfGreater (arr []int, startIdx , val int) int {
    41:	    min := math.MaxInt
    42:	    next:=-1
(dlv) print startIdx
-1
(dlv) n
> main.oddEvenJumps() ./main.go:11 (PC: 0x10ad192)
Values returned:
	~r0: false

     6:	)
     7:	
     8:	func oddEvenJumps(arr []int) int {
     9:	    jmps := 0    
    10:	    for i,val := range arr {
=>  11:	        if CanEnd(arr,i+1, val) {
    12:	            jmps++
    13:	        }
    14:	    }
    15:	    
    16:	    return jmps 
(dlv) n
> main.oddEvenJumps() ./main.go:10 (PC: 0x10ad1af)
     5:		"fmt"
     6:	)
     7:	
     8:	func oddEvenJumps(arr []int) int {
     9:	    jmps := 0    
=>  10:	    for i,val := range arr {
    11:	        if CanEnd(arr,i+1, val) {
    12:	            jmps++
    13:	        }
    14:	    }
    15:	    
(dlv) print i
(dlv) locals
jmps = 0
(dlv) n
> main.oddEvenJumps() ./main.go:11 (PC: 0x10ad16c)
     6:	)
     7:	
     8:	func oddEvenJumps(arr []int) int {
     9:	    jmps := 0    
    10:	    for i,val := range arr {
=>  11:	        if CanEnd(arr,i+1, val) {
    12:	            jmps++
    13:	        }
    14:	    }
    15:	    
    16:	    return jmps 
(dlv) locals
jmps = 0
i = 1
val = 13
(dlv) n
> main.CanEnd() ./main.go:19 (hits goroutine(1):2 total:2) (PC: 0x10ad20a)
    14:	    }
    15:	    
    16:	    return jmps 
    17:	}
    18:	
=>  19:	func CanEnd(arr []int,startIdx, val int) bool {
    20:	    jmps := 1
    21:	    end:=len(arr)
    22:	    
    23:	    for startIdx<end{
    24:	        if jmps % 2 == 1 {
(dlv) n
> main.CanEnd() ./main.go:20 (PC: 0x10ad239)
    15:	    
    16:	    return jmps 
    17:	}
    18:	
    19:	func CanEnd(arr []int,startIdx, val int) bool {
=>  20:	    jmps := 1
    21:	    end:=len(arr)
    22:	    
    23:	    for startIdx<end{
    24:	        if jmps % 2 == 1 {
    25:	            startIdx = getMinOfGreater (arr , startIdx , arr[startIdx])
(dlv) n
> main.CanEnd() ./main.go:21 (PC: 0x10ad242)
    16:	    return jmps 
    17:	}
    18:	
    19:	func CanEnd(arr []int,startIdx, val int) bool {
    20:	    jmps := 1
=>  21:	    end:=len(arr)
    22:	    
    23:	    for startIdx<end{
    24:	        if jmps % 2 == 1 {
    25:	            startIdx = getMinOfGreater (arr , startIdx , arr[startIdx])
    26:	            if startIdx == -1{
(dlv) n
> main.CanEnd() ./main.go:23 (PC: 0x10ad24e)
    18:	
    19:	func CanEnd(arr []int,startIdx, val int) bool {
    20:	    jmps := 1
    21:	    end:=len(arr)
    22:	    
=>  23:	    for startIdx<end{
    24:	        if jmps % 2 == 1 {
    25:	            startIdx = getMinOfGreater (arr , startIdx , arr[startIdx])
    26:	            if startIdx == -1{
    27:	                break
    28:	            }
(dlv) n
> main.CanEnd() ./main.go:24 (PC: 0x10ad25f)
    19:	func CanEnd(arr []int,startIdx, val int) bool {
    20:	    jmps := 1
    21:	    end:=len(arr)
    22:	    
    23:	    for startIdx<end{
=>  24:	        if jmps % 2 == 1 {
    25:	            startIdx = getMinOfGreater (arr , startIdx , arr[startIdx])
    26:	            if startIdx == -1{
    27:	                break
    28:	            }
    29:	        }else{
(dlv) p startIdx
2
(dlv) p val
13
(dlv) n
> main.CanEnd() ./main.go:25 (PC: 0x10ad27f)
    20:	    jmps := 1
    21:	    end:=len(arr)
    22:	    
    23:	    for startIdx<end{
    24:	        if jmps % 2 == 1 {
=>  25:	            startIdx = getMinOfGreater (arr , startIdx , arr[startIdx])
    26:	            if startIdx == -1{
    27:	                break
    28:	            }
    29:	        }else{
    30:	            startIdx = getMaxofSmaller (arr , startIdx , arr[startIdx])
(dlv) locals
jmps = 1
end = 5
(dlv) n
> main.getMinOfGreater() ./main.go:40 (hits goroutine(1):2 total:2) (PC: 0x10ad3a0)
    35:	        jmps++
    36:	    }
    37:	        return startIdx == end -1 
    38:	}
    39:	
=>  40:	func getMinOfGreater (arr []int, startIdx , val int) int {
    41:	    min := math.MaxInt
    42:	    next:=-1
    43:	    for i:=startIdx;i < len(arr);i++ {
    44:	        if arr[i]>val && arr[i]<min{
    45:	            min = arr[i]
(dlv) bp
Breakpoint runtime-fatal-throw (enabled) at 0x1033f60 for runtime.throw() /usr/local/go/src/runtime/panic.go:982 (0)
Breakpoint unrecovered-panic (enabled) at 0x1034320 for runtime.fatalpanic() /usr/local/go/src/runtime/panic.go:1065 (0)
	print runtime.curg._panic.arg
Breakpoint 1 (enabled) at 0x1036446 for runtime.main.func1() /usr/local/go/src/runtime/proc.go:170 (1)
Breakpoint 2 (enabled) at 0x103648a for runtime.main() /usr/local/go/src/runtime/proc.go:145 (1)
Breakpoint 3 (enabled) at 0x1036786 for runtime.main.func2() /usr/local/go/src/runtime/proc.go:203 (0)
Breakpoint 4 (enabled) at 0x10ad0ca for main.oddEvenJumps() ./main.go:8 (1)
Breakpoint 5 (enabled) at 0x10ad20a for main.CanEnd() ./main.go:19 (2)
Breakpoint 6 (enabled) at 0x10ad3a0 for main.getMinOfGreater() ./main.go:40 (2)
Breakpoint 7 (enabled) at 0x10ad4e0 for main.getMaxofSmaller() ./main.go:52 (1)
Breakpoint 8 (enabled) at 0x10ad62f for main.main() ./main.go:65 (1)
(dlv) clear 6
Breakpoint 6 cleared at 0x10ad3a0 for main.getMinOfGreater() ./main.go:40
(dlv) c
> main.getMaxofSmaller() ./main.go:52 (hits goroutine(1):2 total:2) (PC: 0x10ad4e0)
    47:	        }
    48:	    }
    49:	    return next
    50:	}
    51:	
=>  52:	func getMaxofSmaller (arr []int, startIdx , val int) int {
    53:	    max := 0
    54:	        next:=-1
    55:	    for i:=startIdx;i < len(arr);i++ {
    56:	        if arr[i]<val && arr[i]>max{
    57:	            max = arr[i]
(dlv) n
> main.getMaxofSmaller() ./main.go:53 (PC: 0x10ad510)
    48:	    }
    49:	    return next
    50:	}
    51:	
    52:	func getMaxofSmaller (arr []int, startIdx , val int) int {
=>  53:	    max := 0
    54:	        next:=-1
    55:	    for i:=startIdx;i < len(arr);i++ {
    56:	        if arr[i]<val && arr[i]>max{
    57:	            max = arr[i]
    58:	            next = i
(dlv) n
> main.getMaxofSmaller() ./main.go:54 (PC: 0x10ad519)
    49:	    return next
    50:	}
    51:	
    52:	func getMaxofSmaller (arr []int, startIdx , val int) int {
    53:	    max := 0
=>  54:	        next:=-1
    55:	    for i:=startIdx;i < len(arr);i++ {
    56:	        if arr[i]<val && arr[i]>max{
    57:	            max = arr[i]
    58:	            next = i
    59:	        }
(dlv) n
> main.getMaxofSmaller() ./main.go:55 (PC: 0x10ad522)
    50:	}
    51:	
    52:	func getMaxofSmaller (arr []int, startIdx , val int) int {
    53:	    max := 0
    54:	        next:=-1
=>  55:	    for i:=startIdx;i < len(arr);i++ {
    56:	        if arr[i]<val && arr[i]>max{
    57:	            max = arr[i]
    58:	            next = i
    59:	        }
    60:	    }
(dlv) p startIdx
3
(dlv) n
> main.getMaxofSmaller() ./main.go:56 (PC: 0x10ad545)
    51:	
    52:	func getMaxofSmaller (arr []int, startIdx , val int) int {
    53:	    max := 0
    54:	        next:=-1
    55:	    for i:=startIdx;i < len(arr);i++ {
=>  56:	        if arr[i]<val && arr[i]>max{
    57:	            max = arr[i]
    58:	            next = i
    59:	        }
    60:	    }
    61:	    return next
(dlv) help
The following commands are available:

Running the program:
    call ------------------------ Resumes process, injecting a function call (EXPERIMENTAL!!!)
    continue (alias: c) --------- Run until breakpoint or program termination.
    next (alias: n) ------------- Step over to next source line.
    rebuild --------------------- Rebuild the target executable and restarts it. It does not work if the executable was not built by delve.
    restart (alias: r) ---------- Restart process.
    step (alias: s) ------------- Single step through program.
    step-instruction (alias: si)  Single step a single cpu instruction.
    stepout (alias: so) --------- Step out of the current function.

Manipulating breakpoints:
    break (alias: b) ------- Sets a breakpoint.
    breakpoints (alias: bp)  Print out info for active breakpoints.
    clear ------------------ Deletes breakpoint.
    clearall --------------- Deletes multiple breakpoints.
    condition (alias: cond)  Set breakpoint condition.
    on --------------------- Executes a command when a breakpoint is hit.
    toggle ----------------- Toggles on or off a breakpoint.
    trace (alias: t) ------- Set tracepoint.
    watch ------------------ Set watchpoint.

Viewing program variables and memory:
    args ----------------- Print function arguments.
    display -------------- Print value of an expression every time the program stops.
    examinemem (alias: x)  Examine raw memory at the given address.
    locals --------------- Print local variables.
    print (alias: p) ----- Evaluate an expression.
    regs ----------------- Print contents of CPU registers.
    set ------------------ Changes the value of a variable.
    vars ----------------- Print package variables.
    whatis --------------- Prints type of an expression.

Listing and switching between threads and goroutines:
    goroutine (alias: gr) -- Shows or changes current goroutine
    goroutines (alias: grs)  List program goroutines.
    thread (alias: tr) ----- Switch to the specified thread.
    threads ---------------- Print out info for every traced thread.

Viewing the call stack and selecting frames:
    deferred --------- Executes command in the context of a deferred call.
    down ------------- Move the current frame down.
    frame ------------ Set the current frame, or execute command on a different frame.
    stack (alias: bt)  Print stack trace.
    up --------------- Move the current frame up.

Other commands:
    config --------------------- Changes configuration parameters.
    disassemble (alias: disass)  Disassembler.
    dump ----------------------- Creates a core dump from the current process state
    edit (alias: ed) ----------- Open where you are in $DELVE_EDITOR or $EDITOR
    exit (alias: quit | q) ----- Exit the debugger.
    funcs ---------------------- Print list of functions.
    help (alias: h) ------------ Prints the help message.
    libraries ------------------ List loaded dynamic libraries
    list (alias: ls | l) ------- Show source code.
    source --------------------- Executes a file containing a list of delve commands
    sources -------------------- Print list of source files.
    transcript ----------------- Appends command output to a file.
    types ---------------------- Print list of types

Type help followed by a command for full documentation.
(dlv) help watchpoint
(dlv) watchpoint help
(dlv) watch
(dlv) help watch
Set watchpoint.
	
	watch [-r|-w|-rw] <expr>
	
	-r	stops when the memory location is read
	-w	stops when the memory location is written
	-rw	stops when the memory location is read or written

The memory location is specified with the same expression language used by 'print', for example:

	watch v

will watch the address of variable 'v'.

Note that writes that do not change the value of the watched memory address might not be reported.

See also: "help print".
(dlv) watch getMaxofSmaller.next
(dlv) watch -w getMaxofSmaller.next
(dlv) watch -w next
Watchpoint next set at 0xc0000a5db8
(dlv) n
> main.getMaxofSmaller() ./main.go:55 (PC: 0x10ad5d5)
    50:	}
    51:	
    52:	func getMaxofSmaller (arr []int, startIdx , val int) int {
    53:	    max := 0
    54:	        next:=-1
=>  55:	    for i:=startIdx;i < len(arr);i++ {
    56:	        if arr[i]<val && arr[i]>max{
    57:	            max = arr[i]
    58:	            next = i
    59:	        }
    60:	    }
(dlv) n
> main.getMaxofSmaller() ./main.go:56 (PC: 0x10ad545)
    51:	
    52:	func getMaxofSmaller (arr []int, startIdx , val int) int {
    53:	    max := 0
    54:	        next:=-1
    55:	    for i:=startIdx;i < len(arr);i++ {
=>  56:	        if arr[i]<val && arr[i]>max{
    57:	            max = arr[i]
    58:	            next = i
    59:	        }
    60:	    }
    61:	    return next
(dlv) n
> main.getMaxofSmaller() ./main.go:55 (PC: 0x10ad5d5)
    50:	}
    51:	
    52:	func getMaxofSmaller (arr []int, startIdx , val int) int {
    53:	    max := 0
    54:	        next:=-1
=>  55:	    for i:=startIdx;i < len(arr);i++ {
    56:	        if arr[i]<val && arr[i]>max{
    57:	            max = arr[i]
    58:	            next = i
    59:	        }
    60:	    }
(dlv) bp
Breakpoint runtime-fatal-throw (enabled) at 0x1033f60 for runtime.throw() /usr/local/go/src/runtime/panic.go:982 (0)
Breakpoint unrecovered-panic (enabled) at 0x1034320 for runtime.fatalpanic() /usr/local/go/src/runtime/panic.go:1065 (0)
	print runtime.curg._panic.arg
Breakpoint 1 (enabled) at 0x1036446 for runtime.main.func1() /usr/local/go/src/runtime/proc.go:170 (1)
Breakpoint 2 (enabled) at 0x103648a for runtime.main() /usr/local/go/src/runtime/proc.go:145 (1)
Breakpoint 3 (enabled) at 0x1036786 for runtime.main.func2() /usr/local/go/src/runtime/proc.go:203 (0)
Breakpoint 4 (enabled) at 0x10ad0ca for main.oddEvenJumps() ./main.go:8 (1)
Breakpoint 5 (enabled) at 0x10ad20a for main.CanEnd() ./main.go:19 (2)
Breakpoint 7 (enabled) at 0x10ad4e0 for main.getMaxofSmaller() ./main.go:52 (2)
Breakpoint 8 (enabled) at 0x10ad62f for main.main() ./main.go:65 (1)
Watchpoint next (enabled) at 0xc0000a5db8 (0)
(dlv) n
> main.getMaxofSmaller() ./main.go:61 (PC: 0x10ad5eb)
    56:	        if arr[i]<val && arr[i]>max{
    57:	            max = arr[i]
    58:	            next = i
    59:	        }
    60:	    }
=>  61:	    return next
    62:	
    63:	}
    64:	
    65:	func main (){
    66:		fmt.Println(oddEvenJumps([]int{10,13,12,14,15}))
(dlv) n
> main.CanEnd() ./main.go:30 (PC: 0x10ad30c)
Values returned:
	~r0: -1

Watchpoint next went out of scope and was cleared
    25:	            startIdx = getMinOfGreater (arr , startIdx , arr[startIdx])
    26:	            if startIdx == -1{
    27:	                break
    28:	            }
    29:	        }else{
=>  30:	            startIdx = getMaxofSmaller (arr , startIdx , arr[startIdx])
    31:	            if startIdx == -1{
    32:	                break
    33:	            }            
    34:	        }
    35:	        jmps++
(dlv) n
> main.CanEnd() ./main.go:31 (PC: 0x10ad311)
    26:	            if startIdx == -1{
    27:	                break
    28:	            }
    29:	        }else{
    30:	            startIdx = getMaxofSmaller (arr , startIdx , arr[startIdx])
=>  31:	            if startIdx == -1{
    32:	                break
    33:	            }            
    34:	        }
    35:	        jmps++
    36:	    }
(dlv) n
> main.CanEnd() ./main.go:32 (PC: 0x10ad319)
    27:	                break
    28:	            }
    29:	        }else{
    30:	            startIdx = getMaxofSmaller (arr , startIdx , arr[startIdx])
    31:	            if startIdx == -1{
=>  32:	                break
    33:	            }            
    34:	        }
    35:	        jmps++
    36:	    }
    37:	        return startIdx == end -1 
(dlv) locals
jmps = 2
end = 5
(dlv) vars
fmt.ppFree = sync.Pool {noCopy: sync.noCopy {}, local: unsafe.Pointer(0x0), localSize: 0,...+3 more}
fmt.complexError = error(*errors.errorString) 0x1147f18
fmt.boolError = error(*errors.errorString) 0x1147f08
math.useFMA = true
os.ErrInvalid = error(*errors.errorString) 0x11480d8
os.ErrPermission = error(*errors.errorString) 0x1148108
os.ErrExist = error(*errors.errorString) 0x11480c8
os.ErrNotExist = error(*errors.errorString) 0x11480f8
os.ErrClosed = error(*errors.errorString) 0x11480a8
os.ErrNoDeadline = error(*errors.errorString) 0x11480e8
os.ErrDeadlineExceeded = error(*internal/poll.DeadlineExceededError) 0x11480b8
os.ErrProcessDone = error(*errors.errorString) 0x1148118
os.executablePath = "/Users/ramesh/Documents/Repos/go/src/going_in_circles/go/test/__...+9 more"
os.initCwd = "/Users/ramesh/Documents/Repos/go/src/going_in_circles/go/test"
os.initCwdErr = error nil
os.Stdin = (*os.File)(0xc000100000)
os.Stdout = (*os.File)(0xc000100008)
os.Stderr = (*os.File)(0xc000100010)
os.errWriteAtInAppendMode = error(*errors.errorString) 0x1148138
os.Args = []string len: 1, cap: 1, [...]
os.errPatternHasSeparator = error(*errors.errorString) 0x1148128
internal/poll.errEAGAIN = error(syscall.Errno) EAGAIN (35)
internal/poll.errEINVAL = error(syscall.Errno) EINVAL (22)
internal/poll.errENOENT = error(syscall.Errno) ENOENT (2)
internal/poll.ErrFileClosing = error(*errors.errorString) 0x1147f78
internal/poll.ErrNoDeadline = error(*errors.errorString) 0x1147f88
internal/poll.ErrDeadlineExceeded = error(*internal/poll.DeadlineExceededError) 0x1141098
internal/poll.ErrNotPollable = error(*errors.errorString) 0x1147f98
internal/poll.serverInit = sync.Once {done: 0, m: (*sync.Mutex)(0x117703c)}
internal/poll.CloseFunc = syscall.Close
internal/cpu.DebugOptions = true
internal/cpu.CacheLineSize = 64
internal/cpu.X86 = struct { internal/cpu._ internal/cpu.CacheLinePad; HasAES bool; HasADX bool; HasAVX bool; HasAVX2 bool; HasBMI1 bool; HasBMI2 bool; HasERMS bool; HasFMA bool; HasOSXSAVE bool; HasPCLMULQDQ bool; HasPOPCNT bool; HasRDTSCP bool; HasSSE3 bool; HasSSSE3 bool; HasSSE41 bool; HasSSE42 bool; internal/cpu._ internal/cpu.CacheLinePad } {_: (*"internal/cpu.CacheLinePad")(0x11774a0), HasAES: true, HasADX: true,...+15 more}
internal/cpu.options = []internal/cpu.option len: 15, cap: 15, [...]
internal/cpu.maxExtendedFunctionInformation = 2147483656
internal/testlog.logger = sync/atomic.Value {v: interface {} nil}
io/fs.ErrInvalid = error(*errors.errorString) 0x1148068
io/fs.ErrPermission = error(*errors.errorString) 0x1148088
io/fs.ErrExist = error(*errors.errorString) 0x1148058
io/fs.ErrNotExist = error(*errors.errorString) 0x1148078
io/fs.ErrClosed = error(*errors.errorString) 0x1148048
io/fs.SkipDir = error(*errors.errorString) 0x1148098
path.ErrBadPattern = error(*errors.errorString) 0x1148178
time.std0x = [6]int [...]
time.longDayNames = []string len: 7, cap: 7, [...]
time.longMonthNames = []string len: 12, cap: 12, [...]
time.atoiError = error(*errors.errorString) 0x11481b8
time.errBad = error(*errors.errorString) 0x11481d8
time.errLeadingInt = error(*errors.errorString) 0x11481e8
time.unitMap = map[string]uint64 [...]
time.daysBefore = [13]int32 [...]
time.startNano = 38777141535347
time.UTC = (*time.Location)(0x1145040)
time.utcLoc = time.Location {name: "UTC", zone: []time.zone len: 0, cap: 0, nil, tx: []time.zoneTrans len: 0, cap: 0, nil,...+4 more}
time.Local = (*time.Location)(0x11484e0)
time.localLoc = time.Location {name: "", zone: []time.zone len: 0, cap: 0, nil, tx: []time.zoneTrans len: 0, cap: 0, nil,...+4 more}
time.localOnce = sync.Once {done: 0, m: (*sync.Mutex)(0x117705c)}
time.errLocation = error(*errors.errorString) 0x11481f8
time.loadFromEmbeddedTZData = nil
time.badData = error(*errors.errorString) 0x11481c8
time.loadTzinfoFromTzdata = nil
time.zoneSources = []string len: 4, cap: 4, [...]
syscall.envOnce = sync.Once {done: 1, m: (*sync.Mutex)(0x117704c)}
syscall.envLock = sync.RWMutex {w: (*sync.Mutex)(0x11770c0), writerSem: 0, readerSem: 0,...+2 more}
syscall.env = map[string]int [...]
syscall.envs = []string len: 39, cap: 40, [...]
syscall.execveDarwin = syscall.execve
syscall.minRoutingSockaddrLen = 4
syscall._zero = 0
syscall.Stdin = 0
syscall.Stdout = 1
syscall.Stderr = 2
syscall.errEAGAIN = error(syscall.Errno) EAGAIN (35)
syscall.errEINVAL = error(syscall.Errno) EINVAL (22)
syscall.errENOENT = error(syscall.Errno) ENOENT (2)
syscall.errors = [106]string [...]
internal/oserror.ErrInvalid = error(*errors.errorString) 0x1147f48
internal/oserror.ErrPermission = error(*errors.errorString) 0x1147f68
internal/oserror.ErrExist = error(*errors.errorString) 0x1147f38
internal/oserror.ErrNotExist = error(*errors.errorString) 0x1147f58
internal/oserror.ErrClosed = error(*errors.errorString) 0x1147f28
io.ErrShortWrite = error(*errors.errorString) 0x1147ff8
io.errInvalidWrite = error(*errors.errorString) 0x1148018
io.ErrShortBuffer = error(*errors.errorString) 0x1147fe8
io.EOF = error(*errors.errorString) 0x1147fb8
io.ErrUnexpectedEOF = error(*errors.errorString) 0x1148008
io.ErrNoProgress = error(*errors.errorString) 0x1147fd8
io.errWhence = error(*errors.errorString) 0x1148038
io.errOffset = error(*errors.errorString) 0x1148028
io.ErrClosedPipe = error(*errors.errorString) 0x1147fc8
internal/bytealg.MaxLen = 63
reflect.intArgRegs = 9
reflect.floatArgRegs = 15
reflect.floatRegSize = 8
reflect.kindNames = []string len: 27, cap: 27, [...]
reflect.layoutCache = sync.Map {mu: (*sync.Mutex)(0x1148420), read: (*"sync/atomic.Value")(0x1148428), dirty: map[interface {}]*sync.entry nil,...+1 more}
reflect.uint8Type = (*reflect.rtype)(0x10b50e0)
reflect.stringType = (*reflect.rtype)(0x10b4fa0)
reflect.dummy = struct { reflect.b bool; reflect.x interface {} } {b: false, x: interface {} nil}
runtime.useAeshash = true
runtime.aeskeysched = [128]uint8 [...]
runtime.hashkey = [4]uintptr [...]
runtime.iscgo = false
runtime.cgoHasExtraM = false
runtime.cgo_yield = (*unsafe.Pointer)(0x1147dc0)
runtime.ncgocall = 0
runtime.x86HasPOPCNT = true
runtime.x86HasSSE41 = true
runtime.x86HasFMA = true
runtime.useAVXmemmove = true
runtime.cpuprof = runtime.cpuProfile {lock: (*runtime.mutex)(0x114a4e0), on: false, log: *runtime.profBuf nil,...+4 more}
runtime._cgo_setenv = unsafe.Pointer(0x0)
runtime._cgo_unsetenv = unsafe.Pointer(0x0)
runtime.boundsErrorFmts = [9]string [...]
runtime.boundsNegErrorFmts = [8]string [...]
runtime.defaultGOROOT = "/usr/local/go"
runtime.buildVersion = "go1.18.2"
runtime.fastlog2Table = [33]float64 [...]
runtime.inf = +Inf
runtime.itabLock = runtime.mutex {lockRankStruct: runtime.lockRankStruct {}, key: 0}
runtime.itabTable = (*runtime.itabTableType)(0x1146d80)
runtime.itabTableInit = runtime.itabTableType {size: 512, count: 14, entries: [512]*runtime.itab [...]}
runtime.uint16Eface = (unreadable could not resolve interface type)
runtime.uint32Eface = (unreadable could not resolve interface type)
runtime.uint64Eface = (unreadable could not resolve interface type)
runtime.stringEface = (unreadable could not resolve interface type)
runtime.sliceEface = (unreadable could not resolve interface type)
runtime.uint16Type = (*runtime._type)(0x10b4ee0)
runtime.uint32Type = (*runtime._type)(0x10b4f20)
runtime.uint64Type = (*runtime._type)(0x10b4f60)
runtime.stringType = (*runtime._type)(0x10b4e20)
runtime.sliceType = (*runtime._type)(0x10b65e0)
runtime.staticuint64s = [256]uint64 [...]
runtime.lockNames = []string len: 51, cap: 51, [...]
runtime.physPageSize = 4096
runtime.physHugePageSize = 0
runtime.physHugePageShift = 0
runtime.zerobase = 0
runtime.globalAlloc = struct { runtime.mutex; runtime.persistentAlloc } {mutex: (*runtime.mutex)(0x11770a0), persistentAlloc: (*runtime.persistentAlloc)(0x11770a8)}
runtime.persistentChunks = (*runtime.notInHeap)(0x1791000)
runtime.zeroVal = [1024]uint8 [...]
runtime.emptymspan = runtime.mspan {next: *runtime.mspan nil, prev: *runtime.mspan nil, list: *runtime.mSpanList nil,...+18 more}
runtime.useCheckmark = false
runtime.finlock = runtime.mutex {lockRankStruct: runtime.lockRankStruct {}, key: 0}
runtime.fing = (*runtime.g)(0xc000104000)
runtime.finq = *runtime.finblock nil
runtime.finc = *runtime.finblock nil
runtime.finptrmask = [64]uint8 [...]
runtime.fingwait = true
runtime.fingwake = false
runtime.allfin = *runtime.finblock nil
runtime.finalizer1 = [5]uint8 [...]
runtime.fingCreate = 1
runtime.fingRunning = false
runtime.gcphase = 0
runtime.writeBarrier = struct { runtime.enabled bool; runtime.pad [3]uint8; runtime.needed bool; runtime.cgo bool; runtime.alignme uint64 } {enabled: false, pad: [3]uint8 [...], needed: false,...+2 more}
runtime.gcBlackenEnabled = 0
runtime.work = struct { runtime.full runtime.lfstack; runtime.empty runtime.lfstack; runtime.pad0 internal/cpu.CacheLinePad; runtime.wbufSpans struct { runtime.lock runtime.mutex; runtime.free runtime.mSpanList; runtime.busy runtime.mSpanList }; runtime._ uint32; runtime.bytesMarked uint64; runtime.markrootNext uint32; runtime.markrootJobs uint32; runtime.nproc uint32; runtime.tstart int64; runtime.nwait uint32; runtime.nDataRoots int; runtime.nBSSRoots int; runtime.nSpanRoots int; runtime.nStackRoots int; runtime.baseData uint32; runtime.baseBSS uint32; runtime.baseSpans uint32; runtime.baseStacks uint32; runtime.baseEnd uint32; runtime.stackRoots []*runtime.g; runtime.startSema uint32; runtime.markDoneSema uint32; runtime.bgMarkReady runtime.note; runtime.bgMarkDone uint32; runtime.mode runtime.gcMode; runtime.userForced bool; runtime.totaltime int64; runtime.initialHeapLive uint64; runtime.assistQueue struct { runtime.lock runtime.mutex; runtime.q runtime.gQueue }; runtime.sweepWaiters struct { runtime.lock runtime.mutex; runtime.list runtime.gList }; runtime.cycles uint32; runtime.stwprocs int32; runtime.maxprocs int32; runtime.tSweepTerm int64; runtime.tMark int64; runtime.tMarkTerm int64; runtime.tEnd int64; runtime.pauseNS int64; runtime.pauseStart int64; runtime.heap0 uint64; runtime.heap1 uint64; runtime.heap2 uint64; runtime.heapGoal uint64 } {full: 0, empty: 0, pad0: (*"internal/cpu.CacheLinePad")(0x1148710),...+41 more}
runtime.gcMarkDoneFlushed = 0
runtime.poolcleanup = sync.poolCleanup
runtime.oneptrmask = [1]uint8 [...]
runtime.gcController = runtime.gcControllerState {gcPercent: (*"runtime/internal/atomic.Int32")(0x1177840), _: 0, heapMinimum: 4194304,...+29 more}
runtime.scavenge = struct { runtime.lock runtime.mutex; runtime.g *runtime.g; runtime.parked bool; runtime.timer *runtime.timer; runtime.sysmonWake uint32; runtime.printControllerReset bool } {lock: (*runtime.mutex)(0x1148460), g: (*runtime.g)(0xc0000824e0), parked: true,...+3 more}
runtime.sweep = runtime.sweepdata {lock: (*runtime.mutex)(0x11484a0), g: (*runtime.g)(0xc000082340), parked: true,...+5 more}
runtime.mheap_ = runtime.mheap {lock: (*runtime.mutex)(0x1160400), pages: (*runtime.pageAlloc)(0x1160408), sweepgen: 0,...+27 more}
runtime.mSpanStateNames = []string len: 4, cap: 4, [...]
runtime.gcBitsArenas = struct { runtime.lock runtime.mutex; runtime.free *runtime.gcBitsArena; runtime.next *runtime.gcBitsArena; runtime.current *runtime.gcBitsArena; runtime.previous *runtime.gcBitsArena } {lock: (*runtime.mutex)(0x1177120), free: *runtime.gcBitsArena nil, next: (*runtime.gcBitsArena)(0x1741000),...+2 more}
runtime.maxSearchAddr = runtime.offAddr {a: 140737488355327}
runtime.levelBits = [5]uint [...]
runtime.levelShift = [5]uint [...]
runtime.levelLogPages = [5]uint [...]
runtime.proflock = runtime.mutex {lockRankStruct: runtime.lockRankStruct {}, key: 0}
runtime.mbuckets = *runtime.bucket nil
runtime.bbuckets = *runtime.bucket nil
runtime.xbuckets = *runtime.bucket nil
runtime.buckhash = *[179999]*runtime.bucket nil
runtime.bucketmem = 0
runtime.mProf = struct { runtime.cycle uint32; runtime.flushed bool } {cycle: 0, flushed: false}
runtime.blockprofilerate = 0
runtime.mutexprofilerate = 0
runtime.MemProfileRate = 0
runtime.disableMemoryProfiling = true
runtime.tracelock = runtime.mutex {lockRankStruct: runtime.lockRankStruct {}, key: 0}
runtime.minOffAddr = runtime.offAddr {a: 18446603336221196288}
runtime.maxOffAddr = runtime.offAddr {a: 140737488355327}
runtime.spanSetBlockPool = runtime.spanSetBlockAlloc {stack: 0}
runtime.memstats = runtime.mstats {alloc: 0, total_alloc: 0, sys: 0,...+33 more}
runtime.netpollInitLock = runtime.mutex {lockRankStruct: runtime.lockRankStruct {}, key: 0}
runtime.netpollInited = 0
runtime.pollcache = runtime.pollCache {lock: (*runtime.mutex)(0x1177080), first: *runtime.pollDesc nil}
runtime.netpollWaiters = 0
runtime.pdEface = interface {}(*runtime.pollDesc) 0x11411d8
runtime.pdType = (*runtime._type)(0x10b9ce0)
runtime.kq = -1
runtime.netpollBreakRd = 0
runtime.netpollBreakWr = 0
runtime.netpollWakeSig = 0
runtime.sigNoteWrite = 0
runtime.urandom_dev = []uint8 len: 13, cap: 13, [...]
runtime.failthreadcreate = []uint8 len: 40, cap: 40, [...]
runtime.sigset_all = 4294967295
runtime.shiftError = error(runtime.errorString) "negative shift amount"
runtime.divideError = error(runtime.errorString) "integer divide by zero"
runtime.overflowError = error(runtime.errorString) "integer overflow"
runtime.floatError = error(runtime.errorString) "floating point error"
runtime.memoryError = error(runtime.errorString) "invalid memory address or nil pointer dereference"
runtime.runningPanicDefers = 0
runtime.panicking = 0
runtime.paniclk = runtime.mutex {lockRankStruct: runtime.lockRankStruct {}, key: 0}
runtime.didothers = false
runtime.deadlock = runtime.mutex {lockRankStruct: runtime.lockRankStruct {}, key: 0}
runtime.asyncPreemptStack = 472
runtime.printBacklog = [512]uint8 [...]
runtime.printBacklogIndex = 0
runtime.debuglock = runtime.mutex {lockRankStruct: runtime.lockRankStruct {}, key: 0}
runtime.minhexdigits = 0
runtime.modinfo = "0w�\f�t\b\x02A��\a��\x18�path\tcommand-line-arguments\nbuild\t-compiler=gc\nb...+187 more"
runtime.m0 = runtime.m {g0: (*runtime.g)(0x1148560), morebuf: (*runtime.gobuf)(0x11488c8), divmod: 0,...+60 more}
runtime.g0 = runtime.g {stack: (*runtime.stack)(0x1148560), stackguard0: 140702053759432, stackguard1: 140702053759432,...+48 more}
runtime.mcache0 = *runtime.mcache nil
runtime.main_init_done = chan bool 0/0
runtime.mainStarted = true
runtime.runtimeInitTime = 38777141023476
runtime.initSigmask = 0
runtime.badmorestackg0Msg = "fatal: morestack on g0\n"
runtime.badmorestackgsignalMsg = "fatal: morestack on gsignal\n"
runtime.allglock = runtime.mutex {lockRankStruct: runtime.lockRankStruct {}, key: 0}
runtime.allgs = []*runtime.g len: 5, cap: 8, [...]
runtime.allglen = 5
runtime.allgptr = (**runtime.g)(0xc00010e000)
runtime.fastrandseed = 11995571526182586899
runtime.freezing = 0
runtime.worldsema = 1
runtime.gcsema = 1
runtime.earlycgocallback = []uint8 len: 42, cap: 42, [...]
runtime.extram = 0
runtime.extraMCount = 0
runtime.extraMWaiters = 0
runtime.allocmLock = runtime.rwmutex {rLock: (*runtime.mutex)(0x11771e0), readers: 0, readerPass: 0,...+4 more}
runtime.execLock = runtime.rwmutex {rLock: (*runtime.mutex)(0x1177220), readers: 0, readerPass: 0,...+4 more}
runtime.newmHandoff = struct { runtime.lock runtime.mutex; runtime.newm runtime.muintptr; runtime.waiting bool; runtime.wake runtime.note; runtime.haveTemplateThread uint32 } {lock: (*runtime.mutex)(0x1177160), newm: 0, waiting: false,...+2 more}
runtime.pendingPreemptSignals = 0
runtime.prof = struct { runtime.signalLock uint32; runtime.hz int32 } {signalLock: 0, hz: 0}
runtime.forcegcperiod = 120000000000
runtime.starttime = 0
runtime.stealOrder = runtime.randomOrder {count: 8, coprimes: []uint32 len: 4, cap: 4, [...]}
runtime.inittrace = runtime.tracestat {active: false, id: 0, allocs: 0,...+1 more}
runtime.envs = []string len: 39, cap: 39, [...]
runtime.argslice = []string len: 1, cap: 1, [...]
runtime.traceback_cache = 4
runtime.traceback_env = 4
runtime.argc = 1
runtime.argv = (**uint8)(0x7ff7bfeff5f0)
runtime.test_z64 = 3298534883331
runtime.test_x64 = 42
runtime.debug = struct { runtime.cgocheck int32; runtime.clobberfree int32; runtime.efence int32; runtime.gccheckmark int32; runtime.gcpacertrace int32; runtime.gcshrinkstackoff int32; runtime.gcstoptheworld int32; runtime.gctrace int32; runtime.invalidptr int32; runtime.madvdontneed int32; runtime.scavtrace int32; runtime.scheddetail int32; runtime.schedtrace int32; runtime.tracebackancestors int32; runtime.asyncpreemptoff int32; runtime.harddecommit int32; runtime.malloc bool; runtime.allocfreetrace int32; runtime.inittrace int32; runtime.sbrk int32 } {cgocheck: 1, clobberfree: 0, efence: 0,...+17 more}
runtime.dbgvars = []runtime.dbgVar len: 19, cap: 19, [...]
runtime.waitReasonStrings = [27]string [...]
runtime.allm = (*runtime.m)(0xc000080000)
runtime.gomaxprocs = 8
runtime.ncpu = 8
runtime.forcegc = runtime.forcegcstate {lock: (*runtime.mutex)(0x1148300), g: (*runtime.g)(0xc000002680), idle: 1}
runtime.sched = runtime.schedt {goidgen: 48, lastpoll: 38769079268251, pollUntil: 0,...+34 more}
runtime.newprocs = 0
runtime.allpLock = runtime.mutex {lockRankStruct: runtime.lockRankStruct {}, key: 0}
runtime.allp = []*runtime.p len: 8, cap: 8, [...]
runtime.idlepMask = runtime.pMask len: 1, cap: 1, [...]
runtime.timerpMask = runtime.pMask len: 1, cap: 1, [...]
runtime.gcBgMarkWorkerPool = 0
runtime.gcBgMarkWorkerCount = 0
runtime.processorVersionInfo = 526058
runtime.isIntel = true
runtime.islibrary = false
runtime.isarchive = false
runtime.chansendpc = 16795424
runtime.chanrecvpc = 16797984
runtime.semtable = [251]struct { runtime.root runtime.semaRoot; runtime.pad [40]uint8 } [...]
runtime.sigtable = [32]runtime.sigTabT [...]
runtime.fwdSig = [32]uintptr [...]
runtime.handlingSig = [32]uint32 [...]
runtime.signalsOK = true
runtime.sigprofCallers = runtime.cgoCallers [...]
runtime.sigprofCallersUse = 0
runtime.crashing = 0
runtime.testSigtrap = nil
runtime.testSigusr1 = nil
runtime.badginsignalMsg = "fatal: bad g in signal handler\n"
runtime.sigsetAllExiting = 4294967295
runtime.sig = struct { runtime.note runtime.note; runtime.mask [1]uint32; runtime.wanted [1]uint32; runtime.ignored [1]uint32; runtime.recv [1]uint32; runtime.state uint32; runtime.delivering uint32; runtime.inuse bool } {note: (*runtime.note)(0x11771a0), mask: [1]uint32 [...], wanted: [1]uint32 [...],...+5 more}
runtime.class_to_size = [68]uint16 [...]
runtime.class_to_allocnpages = [68]uint8 [...]
runtime.class_to_divmagic = [68]uint32 [...]
runtime.size_to_class8 = [129]uint8 [...]
runtime.size_to_class128 = [249]uint8 [...]
runtime.stackpool = [4]struct { runtime.item runtime.stackpoolItem; runtime._ [40]uint8 } [...]
runtime.stackLarge = struct { runtime.lock runtime.mutex; runtime.free [35]runtime.mSpanList } {lock: (*runtime.mutex)(0x1177ba0), free: [35]runtime.mSpanList [...]}
runtime.maxstacksize = 1000000000
runtime.maxstackceiling = 2000000000
runtime.methodValueCallFrameObjs = [1]runtime.stackObjectRecord [...]
runtime.badsystemstackMsg = "fatal: systemstack called from unexpected goroutine"
runtime.intArgRegs = 9
runtime.pinnedTypemaps = []map[runtime.typeOff]*runtime._type len: 0, cap: 0, nil
runtime.firstmoduledata = runtime.moduledata {pcHeader: (*runtime.pcHeader)(0x10d3ce0), funcnametab: []uint8 len: 49488, cap: 49488, [...], cutab: []uint32 len: 1752, cap: 1752, [...],...+38 more}
runtime.modulesSlice = (*[]*runtime.moduledata)(0xc00000c000)
runtime.faketime = 0
runtime.overrideWrite = nil
runtime.trace = struct { runtime.lock runtime.mutex; runtime.lockOwner *runtime.g; runtime.enabled bool; runtime.shutdown bool; runtime.headerWritten bool; runtime.footerWritten bool; runtime.shutdownSema uint32; runtime.seqStart uint64; runtime.ticksStart int64; runtime.ticksEnd int64; runtime.timeStart int64; runtime.timeEnd int64; runtime.seqGC uint64; runtime.reading runtime.traceBufPtr; runtime.empty runtime.traceBufPtr; runtime.fullHead runtime.traceBufPtr; runtime.fullTail runtime.traceBufPtr; runtime.reader runtime.guintptr; runtime.stackTab runtime.traceStackTable; runtime.stringsLock runtime.mutex; runtime.strings map[string]uint64; runtime.stringSeq uint64; runtime.markWorkerLabels [4]uint64; runtime.bufLock runtime.mutex; runtime.buf runtime.traceBufPtr } {lock: (*runtime.mutex)(0x1150320), lockOwner: *runtime.g nil, enabled: false,...+22 more}
runtime.gStatusStrings = [10]string [...]
runtime.cgoTraceback = unsafe.Pointer(0x0)
runtime.cgoSymbolizer = unsafe.Pointer(0x0)
runtime.reflectOffs = struct { runtime.lock runtime.mutex; runtime.next int32; runtime.m map[int32]unsafe.Pointer; runtime.minv map[unsafe.Pointer]int32 } {lock: (*runtime.mutex)(0x11483e0), next: 0, m: map[int32]unsafe.Pointer nil,...+1 more}
_cgo_init = unsafe.Pointer(0x0)
_cgo_thread_start = unsafe.Pointer(0x0)
_cgo_notify_runtime_init_done = unsafe.Pointer(0x0)
_cgo_callers = unsafe.Pointer(0x0)
_cgo_yield = unsafe.Pointer(0x0)
internal/reflectlite.kindNames = []string len: 27, cap: 27, [...]
unicode.Categories = map[string]*unicode.RangeTable [...]
unicode.Cc = (*unicode.RangeTable)(0x1143440)
unicode.Cf = (*unicode.RangeTable)(0x11449c0)
unicode.Co = (*unicode.RangeTable)(0x1144e80)
unicode.Cs = (*unicode.RangeTable)(0x1141700)
unicode.Nd = (*unicode.RangeTable)(0x1143940)
unicode.L = (*unicode.RangeTable)(0x1141980)
unicode.Lm = (*unicode.RangeTable)(0x1141fc0)
unicode.Lo = (*unicode.RangeTable)(0x11422c0)
unicode.Ll = (*unicode.RangeTable)(0x1141c80)
unicode.M = (*unicode.RangeTable)(0x1142b00)
unicode.Mc = (*unicode.RangeTable)(0x1142e00)
unicode.Me = (*unicode.RangeTable)(0x1143100)
unicode.Mn = (*unicode.RangeTable)(0x1143300)
unicode.Nl = (*unicode.RangeTable)(0x1143cc0)
unicode.No = (*unicode.RangeTable)(0x1144000)
unicode.N = (*unicode.RangeTable)(0x1143640)
unicode.C = (*unicode.RangeTable)(0x1141500)
unicode.Pc = (*unicode.RangeTable)(0x1144680)
unicode.Pd = (*unicode.RangeTable)(0x11448c0)
unicode.Pe = (*unicode.RangeTable)(0x1144bc0)
unicode.Pf = (*unicode.RangeTable)(0x1144c00)
unicode.Pi = (*unicode.RangeTable)(0x1144c40)
unicode.Po = (*unicode.RangeTable)(0x1144c80)
unicode.Ps = (*unicode.RangeTable)(0x1144cc0)
unicode.P = (*unicode.RangeTable)(0x1144380)
unicode.Sc = (*unicode.RangeTable)(0x1144d40)
unicode.Sk = (*unicode.RangeTable)(0x1144d80)
unicode.Sm = (*unicode.RangeTable)(0x1144dc0)
unicode.So = (*unicode.RangeTable)(0x1144e00)
unicode.Z = (*unicode.RangeTable)(0x1144e40)
unicode.S = (*unicode.RangeTable)(0x1144d00)
unicode.Lt = (*unicode.RangeTable)(0x11425c0)
unicode.Lu = (*unicode.RangeTable)(0x1142800)
unicode.Zl = (*unicode.RangeTable)(0x1144ec0)
unicode.Zp = (*unicode.RangeTable)(0x1144f00)
unicode.Zs = (*unicode.RangeTable)(0x1144f40)
unicode.Scripts = map[string]*unicode.RangeTable [...]
unicode.Adlam = (*unicode.RangeTable)(0x1144f80)
unicode.Ahom = (*unicode.RangeTable)(0x1141540)
unicode.Anatolian_Hieroglyphs = (*unicode.RangeTable)(0x1141580)
unicode.Arabic = (*unicode.RangeTable)(0x11415c0)
unicode.Armenian = (*unicode.RangeTable)(0x1141600)
unicode.Avestan = (*unicode.RangeTable)(0x1141640)
unicode.Balinese = (*unicode.RangeTable)(0x1141680)
unicode.Bamum = (*unicode.RangeTable)(0x11416c0)
unicode.Bassa_Vah = (*unicode.RangeTable)(0x1141740)
unicode.Batak = (*unicode.RangeTable)(0x1141780)
unicode.Bengali = (*unicode.RangeTable)(0x11417c0)
unicode.Bhaiksuki = (*unicode.RangeTable)(0x1141800)
unicode.Bopomofo = (*unicode.RangeTable)(0x1141840)
unicode.Brahmi = (*unicode.RangeTable)(0x1141880)
unicode.Braille = (*unicode.RangeTable)(0x11418c0)
unicode.Buginese = (*unicode.RangeTable)(0x1141900)
unicode.Buhid = (*unicode.RangeTable)(0x1141940)
unicode.Canadian_Aboriginal = (*unicode.RangeTable)(0x11419c0)
unicode.Carian = (*unicode.RangeTable)(0x1141a00)
unicode.Caucasian_Albanian = (*unicode.RangeTable)(0x1141a40)
unicode.Chakma = (*unicode.RangeTable)(0x1141a80)
unicode.Cham = (*unicode.RangeTable)(0x1141ac0)
unicode.Cherokee = (*unicode.RangeTable)(0x1141b00)
unicode.Chorasmian = (*unicode.RangeTable)(0x1141b40)
unicode.Common = (*unicode.RangeTable)(0x1141b80)
unicode.Coptic = (*unicode.RangeTable)(0x1141bc0)
unicode.Cuneiform = (*unicode.RangeTable)(0x1141c00)
unicode.Cypriot = (*unicode.RangeTable)(0x1141c40)
unicode.Cyrillic = (*unicode.RangeTable)(0x1141cc0)
unicode.Deseret = (*unicode.RangeTable)(0x1141d00)
unicode.Devanagari = (*unicode.RangeTable)(0x1141d40)
unicode.Dives_Akuru = (*unicode.RangeTable)(0x1141d80)
unicode.Dogra = (*unicode.RangeTable)(0x1141dc0)
unicode.Duployan = (*unicode.RangeTable)(0x1141e00)
unicode.Egyptian_Hieroglyphs = (*unicode.RangeTable)(0x1141e40)
unicode.Elbasan = (*unicode.RangeTable)(0x1141e80)
unicode.Elymaic = (*unicode.RangeTable)(0x1141ec0)
unicode.Ethiopic = (*unicode.RangeTable)(0x1141f00)
unicode.Georgian = (*unicode.RangeTable)(0x1141f40)
unicode.Glagolitic = (*unicode.RangeTable)(0x1141f80)
unicode.Gothic = (*unicode.RangeTable)(0x1142000)
unicode.Grantha = (*unicode.RangeTable)(0x1142040)
unicode.Greek = (*unicode.RangeTable)(0x1142080)
unicode.Gujarati = (*unicode.RangeTable)(0x11420c0)
unicode.Gunjala_Gondi = (*unicode.RangeTable)(0x1142100)
unicode.Gurmukhi = (*unicode.RangeTable)(0x1142140)
unicode.Han = (*unicode.RangeTable)(0x1142180)
unicode.Hangul = (*unicode.RangeTable)(0x11421c0)
unicode.Hanifi_Rohingya = (*unicode.RangeTable)(0x1142200)
unicode.Hanunoo = (*unicode.RangeTable)(0x1142240)
unicode.Hatran = (*unicode.RangeTable)(0x1142280)
unicode.Hebrew = (*unicode.RangeTable)(0x1142300)
unicode.Hiragana = (*unicode.RangeTable)(0x1142340)
unicode.Imperial_Aramaic = (*unicode.RangeTable)(0x1142380)
unicode.Inherited = (*unicode.RangeTable)(0x11423c0)
unicode.Inscriptional_Pahlavi = (*unicode.RangeTable)(0x1142400)
unicode.Inscriptional_Parthian = (*unicode.RangeTable)(0x1142440)
unicode.Javanese = (*unicode.RangeTable)(0x1142480)
unicode.Kaithi = (*unicode.RangeTable)(0x11424c0)
unicode.Kannada = (*unicode.RangeTable)(0x1142500)
unicode.Katakana = (*unicode.RangeTable)(0x1142540)
unicode.Kayah_Li = (*unicode.RangeTable)(0x1142580)
unicode.Kharoshthi = (*unicode.RangeTable)(0x1142600)
unicode.Khitan_Small_Script = (*unicode.RangeTable)(0x1142640)
unicode.Khmer = (*unicode.RangeTable)(0x1142680)
unicode.Khojki = (*unicode.RangeTable)(0x11426c0)
unicode.Khudawadi = (*unicode.RangeTable)(0x1142700)
unicode.Lao = (*unicode.RangeTable)(0x1142740)
unicode.Latin = (*unicode.RangeTable)(0x1142780)
unicode.Lepcha = (*unicode.RangeTable)(0x11427c0)
unicode.Limbu = (*unicode.RangeTable)(0x1142840)
unicode.Linear_A = (*unicode.RangeTable)(0x1142880)
unicode.Linear_B = (*unicode.RangeTable)(0x11428c0)
unicode.Lisu = (*unicode.RangeTable)(0x1142900)
unicode.Lycian = (*unicode.RangeTable)(0x1142940)
unicode.Lydian = (*unicode.RangeTable)(0x1142980)
unicode.Mahajani = (*unicode.RangeTable)(0x11429c0)
unicode.Makasar = (*unicode.RangeTable)(0x1142a00)
unicode.Malayalam = (*unicode.RangeTable)(0x1142a40)
unicode.Mandaic = (*unicode.RangeTable)(0x1142a80)
unicode.Manichaean = (*unicode.RangeTable)(0x1142ac0)
unicode.Marchen = (*unicode.RangeTable)(0x1142b40)
unicode.Masaram_Gondi = (*unicode.RangeTable)(0x1142b80)
unicode.Medefaidrin = (*unicode.RangeTable)(0x1142bc0)
unicode.Meetei_Mayek = (*unicode.RangeTable)(0x1142c00)
unicode.Mende_Kikakui = (*unicode.RangeTable)(0x1142c40)
unicode.Meroitic_Cursive = (*unicode.RangeTable)(0x1142c80)
unicode.Meroitic_Hieroglyphs = (*unicode.RangeTable)(0x1142cc0)
unicode.Miao = (*unicode.RangeTable)(0x1142d00)
unicode.Modi = (*unicode.RangeTable)(0x1142d40)
unicode.Mongolian = (*unicode.RangeTable)(0x1142d80)
unicode.Mro = (*unicode.RangeTable)(0x1142dc0)
unicode.Multani = (*unicode.RangeTable)(0x1142e40)
unicode.Myanmar = (*unicode.RangeTable)(0x1142e80)
unicode.Nabataean = (*unicode.RangeTable)(0x1142ec0)
unicode.Nandinagari = (*unicode.RangeTable)(0x1142f00)
unicode.New_Tai_Lue = (*unicode.RangeTable)(0x1142f40)
unicode.Newa = (*unicode.RangeTable)(0x1142f80)
unicode.Nko = (*unicode.RangeTable)(0x1142fc0)
unicode.Nushu = (*unicode.RangeTable)(0x1143000)
unicode.Nyiakeng_Puachue_Hmong = (*unicode.RangeTable)(0x1143040)
unicode.Ogham = (*unicode.RangeTable)(0x1143080)
unicode.Ol_Chiki = (*unicode.RangeTable)(0x11430c0)
unicode.Old_Hungarian = (*unicode.RangeTable)(0x1143140)
unicode.Old_Italic = (*unicode.RangeTable)(0x1143180)
unicode.Old_North_Arabian = (*unicode.RangeTable)(0x11431c0)
unicode.Old_Permic = (*unicode.RangeTable)(0x1143200)
unicode.Old_Persian = (*unicode.RangeTable)(0x1143240)
unicode.Old_Sogdian = (*unicode.RangeTable)(0x1143280)
unicode.Old_South_Arabian = (*unicode.RangeTable)(0x11432c0)
unicode.Old_Turkic = (*unicode.RangeTable)(0x1143340)
unicode.Oriya = (*unicode.RangeTable)(0x1143380)
unicode.Osage = (*unicode.RangeTable)(0x11433c0)
unicode.Osmanya = (*unicode.RangeTable)(0x1143400)
unicode.Pahawh_Hmong = (*unicode.RangeTable)(0x1143480)
unicode.Palmyrene = (*unicode.RangeTable)(0x11434c0)
unicode.Pau_Cin_Hau = (*unicode.RangeTable)(0x1143500)
unicode.Phags_Pa = (*unicode.RangeTable)(0x1143540)
unicode.Phoenician = (*unicode.RangeTable)(0x1143580)
unicode.Psalter_Pahlavi = (*unicode.RangeTable)(0x11435c0)
unicode.Rejang = (*unicode.RangeTable)(0x1143600)
unicode.Runic = (*unicode.RangeTable)(0x1143680)
unicode.Samaritan = (*unicode.RangeTable)(0x11436c0)
unicode.Saurashtra = (*unicode.RangeTable)(0x1143700)
unicode.Sharada = (*unicode.RangeTable)(0x1143740)
unicode.Shavian = (*unicode.RangeTable)(0x1143780)
unicode.Siddham = (*unicode.RangeTable)(0x11437c0)
unicode.SignWriting = (*unicode.RangeTable)(0x1143800)
unicode.Sinhala = (*unicode.RangeTable)(0x1143840)
unicode.Sogdian = (*unicode.RangeTable)(0x1143880)
unicode.Sora_Sompeng = (*unicode.RangeTable)(0x11438c0)
unicode.Soyombo = (*unicode.RangeTable)(0x1143900)
unicode.Sundanese = (*unicode.RangeTable)(0x1143980)
unicode.Syloti_Nagri = (*unicode.RangeTable)(0x11439c0)
unicode.Syriac = (*unicode.RangeTable)(0x1143a00)
unicode.Tagalog = (*unicode.RangeTable)(0x1143a40)
unicode.Tagbanwa = (*unicode.RangeTable)(0x1143a80)
unicode.Tai_Le = (*unicode.RangeTable)(0x1143ac0)
unicode.Tai_Tham = (*unicode.RangeTable)(0x1143b00)
unicode.Tai_Viet = (*unicode.RangeTable)(0x1143b40)
unicode.Takri = (*unicode.RangeTable)(0x1143b80)
unicode.Tamil = (*unicode.RangeTable)(0x1143bc0)
unicode.Tangut = (*unicode.RangeTable)(0x1143c00)
unicode.Telugu = (*unicode.RangeTable)(0x1143c40)
unicode.Thaana = (*unicode.RangeTable)(0x1143c80)
unicode.Thai = (*unicode.RangeTable)(0x1143d00)
unicode.Tibetan = (*unicode.RangeTable)(0x1143d40)
unicode.Tifinagh = (*unicode.RangeTable)(0x1143d80)
unicode.Tirhuta = (*unicode.RangeTable)(0x1143dc0)
unicode.Ugaritic = (*unicode.RangeTable)(0x1143e00)
unicode.Vai = (*unicode.RangeTable)(0x1143e40)
unicode.Wancho = (*unicode.RangeTable)(0x1143e80)
unicode.Warang_Citi = (*unicode.RangeTable)(0x1143ec0)
unicode.Yezidi = (*unicode.RangeTable)(0x1143f00)
unicode.Yi = (*unicode.RangeTable)(0x1143f40)
unicode.Zanabazar_Square = (*unicode.RangeTable)(0x1143f80)
unicode.Properties = map[string]*unicode.RangeTable [...]
unicode.ASCII_Hex_Digit = (*unicode.RangeTable)(0x1143fc0)
unicode.Bidi_Control = (*unicode.RangeTable)(0x1144040)
unicode.Dash = (*unicode.RangeTable)(0x1144080)
unicode.Deprecated = (*unicode.RangeTable)(0x11440c0)
unicode.Diacritic = (*unicode.RangeTable)(0x1144100)
unicode.Extender = (*unicode.RangeTable)(0x1144140)
unicode.Hex_Digit = (*unicode.RangeTable)(0x1144180)
unicode.Hyphen = (*unicode.RangeTable)(0x11441c0)
unicode.IDS_Binary_Operator = (*unicode.RangeTable)(0x1144200)
unicode.IDS_Trinary_Operator = (*unicode.RangeTable)(0x1144240)
unicode.Ideographic = (*unicode.RangeTable)(0x1144280)
unicode.Join_Control = (*unicode.RangeTable)(0x11442c0)
unicode.Logical_Order_Exception = (*unicode.RangeTable)(0x1144300)
unicode.Noncharacter_Code_Point = (*unicode.RangeTable)(0x1144340)
unicode.Other_Alphabetic = (*unicode.RangeTable)(0x11443c0)
unicode.Other_Default_Ignorable_Code_Point = (*unicode.RangeTable)(0x1144400)
unicode.Other_Grapheme_Extend = (*unicode.RangeTable)(0x1144440)
unicode.Other_ID_Continue = (*unicode.RangeTable)(0x1144480)
unicode.Other_ID_Start = (*unicode.RangeTable)(0x11444c0)
unicode.Other_Lowercase = (*unicode.RangeTable)(0x1144500)
unicode.Other_Math = (*unicode.RangeTable)(0x1144540)
unicode.Other_Uppercase = (*unicode.RangeTable)(0x1144580)
unicode.Pattern_Syntax = (*unicode.RangeTable)(0x11445c0)
unicode.Pattern_White_Space = (*unicode.RangeTable)(0x1144600)
unicode.Prepended_Concatenation_Mark = (*unicode.RangeTable)(0x1144640)
unicode.Quotation_Mark = (*unicode.RangeTable)(0x11446c0)
unicode.Radical = (*unicode.RangeTable)(0x1144700)
unicode.Regional_Indicator = (*unicode.RangeTable)(0x1144740)
unicode.Sentence_Terminal = (*unicode.RangeTable)(0x1144780)
unicode.Soft_Dotted = (*unicode.RangeTable)(0x11447c0)
unicode.Terminal_Punctuation = (*unicode.RangeTable)(0x1144800)
unicode.Unified_Ideograph = (*unicode.RangeTable)(0x1144840)
unicode.Variation_Selector = (*unicode.RangeTable)(0x1144880)
unicode.White_Space = (*unicode.RangeTable)(0x1144900)
unicode.FoldCategory = map[string]*unicode.RangeTable [...]
unicode.foldL = (*unicode.RangeTable)(0x1144940)
unicode.foldLl = (*unicode.RangeTable)(0x1144980)
unicode.foldLt = (*unicode.RangeTable)(0x1144a00)
unicode.foldLu = (*unicode.RangeTable)(0x1144a40)
unicode.foldM = (*unicode.RangeTable)(0x1144a80)
unicode.foldMn = (*unicode.RangeTable)(0x1144ac0)
unicode.FoldScript = map[string]*unicode.RangeTable [...]
unicode.foldCommon = (*unicode.RangeTable)(0x1144b00)
unicode.foldGreek = (*unicode.RangeTable)(0x1144b40)
unicode.foldInherited = (*unicode.RangeTable)(0x1144b80)
errors.errorType = internal/reflectlite.Type(*internal/reflectlite.rtype) 0x1147ef8
unicode/utf8.first = [256]uint8 [...]
unicode/utf8.acceptRanges = [16]unicode/utf8.acceptRange [...]
strconv.optimize = true
strconv.ErrRange = error(*errors.errorString) 0x1148198
strconv.ErrSyntax = error(*errors.errorString) 0x11481a8
strconv.leftcheats = []strconv.leftCheat len: 61, cap: 61, [...]
strconv.detailedPowersOfTen = [696][2]uint64 [...]
strconv.float32info = strconv.floatInfo {mantbits: 23, expbits: 8, bias: -127}
strconv.float64info = strconv.floatInfo {mantbits: 52, expbits: 11, bias: -1023}
strconv.uint64pow10 = [20]uint64 [...]
strconv.isPrint16 = []uint16 len: 434, cap: 434, [...]
strconv.isNotPrint16 = []uint16 len: 132, cap: 132, [...]
strconv.isPrint32 = []uint32 len: 468, cap: 468, [...]
strconv.isNotPrint32 = []uint16 len: 95, cap: 95, [...]
strconv.isGraphic = []uint16 len: 16, cap: 16, [...]
sync/atomic.firstStoreInProgress = 0
sync.expunged = unsafe.Pointer(0xc00008e040)
sync.allPoolsMu = sync.Mutex {state: 0, sema: 0}
sync.allPools = []*sync.Pool len: 0, cap: 0, nil
sync.oldPools = []*sync.Pool len: 0, cap: 0, nil
(dlv) vars
fmt.ppFree = sync.Pool {noCopy: sync.noCopy {}, local: unsafe.Pointer(0x0), localSize: 0,...+3 more}
fmt.complexError = error(*errors.errorString) 0x1147f18
fmt.boolError = error(*errors.errorString) 0x1147f08
math.useFMA = true
os.ErrInvalid = error(*errors.errorString) 0x11480d8
os.ErrPermission = error(*errors.errorString) 0x1148108
os.ErrExist = error(*errors.errorString) 0x11480c8
os.ErrNotExist = error(*errors.errorString) 0x11480f8
os.ErrClosed = error(*errors.errorString) 0x11480a8
os.ErrNoDeadline = error(*errors.errorString) 0x11480e8
os.ErrDeadlineExceeded = error(*internal/poll.DeadlineExceededError) 0x11480b8
os.ErrProcessDone = error(*errors.errorString) 0x1148118
os.executablePath = "/Users/ramesh/Documents/Repos/go/src/going_in_circles/go/test/__...+9 more"
os.initCwd = "/Users/ramesh/Documents/Repos/go/src/going_in_circles/go/test"
os.initCwdErr = error nil
os.Stdin = (*os.File)(0xc000100000)
os.Stdout = (*os.File)(0xc000100008)
os.Stderr = (*os.File)(0xc000100010)
os.errWriteAtInAppendMode = error(*errors.errorString) 0x1148138
os.Args = []string len: 1, cap: 1, [...]
os.errPatternHasSeparator = error(*errors.errorString) 0x1148128
internal/poll.errEAGAIN = error(syscall.Errno) EAGAIN (35)
internal/poll.errEINVAL = error(syscall.Errno) EINVAL (22)
internal/poll.errENOENT = error(syscall.Errno) ENOENT (2)
internal/poll.ErrFileClosing = error(*errors.errorString) 0x1147f78
internal/poll.ErrNoDeadline = error(*errors.errorString) 0x1147f88
internal/poll.ErrDeadlineExceeded = error(*internal/poll.DeadlineExceededError) 0x1141098
internal/poll.ErrNotPollable = error(*errors.errorString) 0x1147f98
internal/poll.serverInit = sync.Once {done: 0, m: (*sync.Mutex)(0x117703c)}
internal/poll.CloseFunc = syscall.Close
internal/cpu.DebugOptions = true
internal/cpu.CacheLineSize = 64
internal/cpu.X86 = struct { internal/cpu._ internal/cpu.CacheLinePad; HasAES bool; HasADX bool; HasAVX bool; HasAVX2 bool; HasBMI1 bool; HasBMI2 bool; HasERMS bool; HasFMA bool; HasOSXSAVE bool; HasPCLMULQDQ bool; HasPOPCNT bool; HasRDTSCP bool; HasSSE3 bool; HasSSSE3 bool; HasSSE41 bool; HasSSE42 bool; internal/cpu._ internal/cpu.CacheLinePad } {_: (*"internal/cpu.CacheLinePad")(0x11774a0), HasAES: true, HasADX: true,...+15 more}
internal/cpu.options = []internal/cpu.option len: 15, cap: 15, [...]
internal/cpu.maxExtendedFunctionInformation = 2147483656
internal/testlog.logger = sync/atomic.Value {v: interface {} nil}
io/fs.ErrInvalid = error(*errors.errorString) 0x1148068
io/fs.ErrPermission = error(*errors.errorString) 0x1148088
io/fs.ErrExist = error(*errors.errorString) 0x1148058
io/fs.ErrNotExist = error(*errors.errorString) 0x1148078
io/fs.ErrClosed = error(*errors.errorString) 0x1148048
io/fs.SkipDir = error(*errors.errorString) 0x1148098
path.ErrBadPattern = error(*errors.errorString) 0x1148178
time.std0x = [6]int [...]
time.longDayNames = []string len: 7, cap: 7, [...]
time.longMonthNames = []string len: 12, cap: 12, [...]
time.atoiError = error(*errors.errorString) 0x11481b8
time.errBad = error(*errors.errorString) 0x11481d8
time.errLeadingInt = error(*errors.errorString) 0x11481e8
time.unitMap = map[string]uint64 [...]
time.daysBefore = [13]int32 [...]
time.startNano = 38777141535347
time.UTC = (*time.Location)(0x1145040)
time.utcLoc = time.Location {name: "UTC", zone: []time.zone len: 0, cap: 0, nil, tx: []time.zoneTrans len: 0, cap: 0, nil,...+4 more}
time.Local = (*time.Location)(0x11484e0)
time.localLoc = time.Location {name: "", zone: []time.zone len: 0, cap: 0, nil, tx: []time.zoneTrans len: 0, cap: 0, nil,...+4 more}
time.localOnce = sync.Once {done: 0, m: (*sync.Mutex)(0x117705c)}
time.errLocation = error(*errors.errorString) 0x11481f8
time.loadFromEmbeddedTZData = nil
time.badData = error(*errors.errorString) 0x11481c8
time.loadTzinfoFromTzdata = nil
time.zoneSources = []string len: 4, cap: 4, [...]
syscall.envOnce = sync.Once {done: 1, m: (*sync.Mutex)(0x117704c)}
syscall.envLock = sync.RWMutex {w: (*sync.Mutex)(0x11770c0), writerSem: 0, readerSem: 0,...+2 more}
syscall.env = map[string]int [...]
syscall.envs = []string len: 39, cap: 40, [...]
syscall.execveDarwin = syscall.execve
syscall.minRoutingSockaddrLen = 4
syscall._zero = 0
syscall.Stdin = 0
syscall.Stdout = 1
syscall.Stderr = 2
syscall.errEAGAIN = error(syscall.Errno) EAGAIN (35)
syscall.errEINVAL = error(syscall.Errno) EINVAL (22)
syscall.errENOENT = error(syscall.Errno) ENOENT (2)
syscall.errors = [106]string [...]
internal/oserror.ErrInvalid = error(*errors.errorString) 0x1147f48
internal/oserror.ErrPermission = error(*errors.errorString) 0x1147f68
internal/oserror.ErrExist = error(*errors.errorString) 0x1147f38
internal/oserror.ErrNotExist = error(*errors.errorString) 0x1147f58
internal/oserror.ErrClosed = error(*errors.errorString) 0x1147f28
io.ErrShortWrite = error(*errors.errorString) 0x1147ff8
io.errInvalidWrite = error(*errors.errorString) 0x1148018
io.ErrShortBuffer = error(*errors.errorString) 0x1147fe8
io.EOF = error(*errors.errorString) 0x1147fb8
io.ErrUnexpectedEOF = error(*errors.errorString) 0x1148008
io.ErrNoProgress = error(*errors.errorString) 0x1147fd8
io.errWhence = error(*errors.errorString) 0x1148038
io.errOffset = error(*errors.errorString) 0x1148028
io.ErrClosedPipe = error(*errors.errorString) 0x1147fc8
internal/bytealg.MaxLen = 63
reflect.intArgRegs = 9
reflect.floatArgRegs = 15
reflect.floatRegSize = 8
reflect.kindNames = []string len: 27, cap: 27, [...]
reflect.layoutCache = sync.Map {mu: (*sync.Mutex)(0x1148420), read: (*"sync/atomic.Value")(0x1148428), dirty: map[interface {}]*sync.entry nil,...+1 more}
reflect.uint8Type = (*reflect.rtype)(0x10b50e0)
reflect.stringType = (*reflect.rtype)(0x10b4fa0)
reflect.dummy = struct { reflect.b bool; reflect.x interface {} } {b: false, x: interface {} nil}
runtime.useAeshash = true
runtime.aeskeysched = [128]uint8 [...]
runtime.hashkey = [4]uintptr [...]
runtime.iscgo = false
runtime.cgoHasExtraM = false
runtime.cgo_yield = (*unsafe.Pointer)(0x1147dc0)
runtime.ncgocall = 0
runtime.x86HasPOPCNT = true
runtime.x86HasSSE41 = true
runtime.x86HasFMA = true
runtime.useAVXmemmove = true
runtime.cpuprof = runtime.cpuProfile {lock: (*runtime.mutex)(0x114a4e0), on: false, log: *runtime.profBuf nil,...+4 more}
runtime._cgo_setenv = unsafe.Pointer(0x0)
runtime._cgo_unsetenv = unsafe.Pointer(0x0)
runtime.boundsErrorFmts = [9]string [...]
runtime.boundsNegErrorFmts = [8]string [...]
runtime.defaultGOROOT = "/usr/local/go"
runtime.buildVersion = "go1.18.2"
runtime.fastlog2Table = [33]float64 [...]
runtime.inf = +Inf
runtime.itabLock = runtime.mutex {lockRankStruct: runtime.lockRankStruct {}, key: 0}
runtime.itabTable = (*runtime.itabTableType)(0x1146d80)
runtime.itabTableInit = runtime.itabTableType {size: 512, count: 14, entries: [512]*runtime.itab [...]}
runtime.uint16Eface = (unreadable could not resolve interface type)
runtime.uint32Eface = (unreadable could not resolve interface type)
runtime.uint64Eface = (unreadable could not resolve interface type)
runtime.stringEface = (unreadable could not resolve interface type)
runtime.sliceEface = (unreadable could not resolve interface type)
runtime.uint16Type = (*runtime._type)(0x10b4ee0)
runtime.uint32Type = (*runtime._type)(0x10b4f20)
runtime.uint64Type = (*runtime._type)(0x10b4f60)
runtime.stringType = (*runtime._type)(0x10b4e20)
runtime.sliceType = (*runtime._type)(0x10b65e0)
runtime.staticuint64s = [256]uint64 [...]
runtime.lockNames = []string len: 51, cap: 51, [...]
runtime.physPageSize = 4096
runtime.physHugePageSize = 0
runtime.physHugePageShift = 0
runtime.zerobase = 0
runtime.globalAlloc = struct { runtime.mutex; runtime.persistentAlloc } {mutex: (*runtime.mutex)(0x11770a0), persistentAlloc: (*runtime.persistentAlloc)(0x11770a8)}
runtime.persistentChunks = (*runtime.notInHeap)(0x1791000)
runtime.zeroVal = [1024]uint8 [...]
runtime.emptymspan = runtime.mspan {next: *runtime.mspan nil, prev: *runtime.mspan nil, list: *runtime.mSpanList nil,...+18 more}
runtime.useCheckmark = false
runtime.finlock = runtime.mutex {lockRankStruct: runtime.lockRankStruct {}, key: 0}
runtime.fing = (*runtime.g)(0xc000104000)
runtime.finq = *runtime.finblock nil
runtime.finc = *runtime.finblock nil
runtime.finptrmask = [64]uint8 [...]
runtime.fingwait = true
runtime.fingwake = false
runtime.allfin = *runtime.finblock nil
runtime.finalizer1 = [5]uint8 [...]
runtime.fingCreate = 1
runtime.fingRunning = false
runtime.gcphase = 0
runtime.writeBarrier = struct { runtime.enabled bool; runtime.pad [3]uint8; runtime.needed bool; runtime.cgo bool; runtime.alignme uint64 } {enabled: false, pad: [3]uint8 [...], needed: false,...+2 more}
runtime.gcBlackenEnabled = 0
runtime.work = struct { runtime.full runtime.lfstack; runtime.empty runtime.lfstack; runtime.pad0 internal/cpu.CacheLinePad; runtime.wbufSpans struct { runtime.lock runtime.mutex; runtime.free runtime.mSpanList; runtime.busy runtime.mSpanList }; runtime._ uint32; runtime.bytesMarked uint64; runtime.markrootNext uint32; runtime.markrootJobs uint32; runtime.nproc uint32; runtime.tstart int64; runtime.nwait uint32; runtime.nDataRoots int; runtime.nBSSRoots int; runtime.nSpanRoots int; runtime.nStackRoots int; runtime.baseData uint32; runtime.baseBSS uint32; runtime.baseSpans uint32; runtime.baseStacks uint32; runtime.baseEnd uint32; runtime.stackRoots []*runtime.g; runtime.startSema uint32; runtime.markDoneSema uint32; runtime.bgMarkReady runtime.note; runtime.bgMarkDone uint32; runtime.mode runtime.gcMode; runtime.userForced bool; runtime.totaltime int64; runtime.initialHeapLive uint64; runtime.assistQueue struct { runtime.lock runtime.mutex; runtime.q runtime.gQueue }; runtime.sweepWaiters struct { runtime.lock runtime.mutex; runtime.list runtime.gList }; runtime.cycles uint32; runtime.stwprocs int32; runtime.maxprocs int32; runtime.tSweepTerm int64; runtime.tMark int64; runtime.tMarkTerm int64; runtime.tEnd int64; runtime.pauseNS int64; runtime.pauseStart int64; runtime.heap0 uint64; runtime.heap1 uint64; runtime.heap2 uint64; runtime.heapGoal uint64 } {full: 0, empty: 0, pad0: (*"internal/cpu.CacheLinePad")(0x1148710),...+41 more}
runtime.gcMarkDoneFlushed = 0
runtime.poolcleanup = sync.poolCleanup
runtime.oneptrmask = [1]uint8 [...]
runtime.gcController = runtime.gcControllerState {gcPercent: (*"runtime/internal/atomic.Int32")(0x1177840), _: 0, heapMinimum: 4194304,...+29 more}
runtime.scavenge = struct { runtime.lock runtime.mutex; runtime.g *runtime.g; runtime.parked bool; runtime.timer *runtime.timer; runtime.sysmonWake uint32; runtime.printControllerReset bool } {lock: (*runtime.mutex)(0x1148460), g: (*runtime.g)(0xc0000824e0), parked: true,...+3 more}
runtime.sweep = runtime.sweepdata {lock: (*runtime.mutex)(0x11484a0), g: (*runtime.g)(0xc000082340), parked: true,...+5 more}
runtime.mheap_ = runtime.mheap {lock: (*runtime.mutex)(0x1160400), pages: (*runtime.pageAlloc)(0x1160408), sweepgen: 0,...+27 more}
runtime.mSpanStateNames = []string len: 4, cap: 4, [...]
runtime.gcBitsArenas = struct { runtime.lock runtime.mutex; runtime.free *runtime.gcBitsArena; runtime.next *runtime.gcBitsArena; runtime.current *runtime.gcBitsArena; runtime.previous *runtime.gcBitsArena } {lock: (*runtime.mutex)(0x1177120), free: *runtime.gcBitsArena nil, next: (*runtime.gcBitsArena)(0x1741000),...+2 more}
runtime.maxSearchAddr = runtime.offAddr {a: 140737488355327}
runtime.levelBits = [5]uint [...]
runtime.levelShift = [5]uint [...]
runtime.levelLogPages = [5]uint [...]
runtime.proflock = runtime.mutex {lockRankStruct: runtime.lockRankStruct {}, key: 0}
runtime.mbuckets = *runtime.bucket nil
runtime.bbuckets = *runtime.bucket nil
runtime.xbuckets = *runtime.bucket nil
runtime.buckhash = *[179999]*runtime.bucket nil
runtime.bucketmem = 0
runtime.mProf = struct { runtime.cycle uint32; runtime.flushed bool } {cycle: 0, flushed: false}
runtime.blockprofilerate = 0
runtime.mutexprofilerate = 0
runtime.MemProfileRate = 0
runtime.disableMemoryProfiling = true
runtime.tracelock = runtime.mutex {lockRankStruct: runtime.lockRankStruct {}, key: 0}
runtime.minOffAddr = runtime.offAddr {a: 18446603336221196288}
runtime.maxOffAddr = runtime.offAddr {a: 140737488355327}
runtime.spanSetBlockPool = runtime.spanSetBlockAlloc {stack: 0}
runtime.memstats = runtime.mstats {alloc: 0, total_alloc: 0, sys: 0,...+33 more}
runtime.netpollInitLock = runtime.mutex {lockRankStruct: runtime.lockRankStruct {}, key: 0}
runtime.netpollInited = 0
runtime.pollcache = runtime.pollCache {lock: (*runtime.mutex)(0x1177080), first: *runtime.pollDesc nil}
runtime.netpollWaiters = 0
runtime.pdEface = interface {}(*runtime.pollDesc) 0x11411d8
runtime.pdType = (*runtime._type)(0x10b9ce0)
runtime.kq = -1
runtime.netpollBreakRd = 0
runtime.netpollBreakWr = 0
runtime.netpollWakeSig = 0
runtime.sigNoteWrite = 0
runtime.urandom_dev = []uint8 len: 13, cap: 13, [...]
runtime.failthreadcreate = []uint8 len: 40, cap: 40, [...]
runtime.sigset_all = 4294967295
runtime.shiftError = error(runtime.errorString) "negative shift amount"
runtime.divideError = error(runtime.errorString) "integer divide by zero"
runtime.overflowError = error(runtime.errorString) "integer overflow"
runtime.floatError = error(runtime.errorString) "floating point error"
runtime.memoryError = error(runtime.errorString) "invalid memory address or nil pointer dereference"
runtime.runningPanicDefers = 0
runtime.panicking = 0
runtime.paniclk = runtime.mutex {lockRankStruct: runtime.lockRankStruct {}, key: 0}
runtime.didothers = false
runtime.deadlock = runtime.mutex {lockRankStruct: runtime.lockRankStruct {}, key: 0}
runtime.asyncPreemptStack = 472
runtime.printBacklog = [512]uint8 [...]
runtime.printBacklogIndex = 0
runtime.debuglock = runtime.mutex {lockRankStruct: runtime.lockRankStruct {}, key: 0}
runtime.minhexdigits = 0
runtime.modinfo = "0w�\f�t\b\x02A��\a��\x18�path\tcommand-line-arguments\nbuild\t-compiler=gc\nb...+187 more"
runtime.m0 = runtime.m {g0: (*runtime.g)(0x1148560), morebuf: (*runtime.gobuf)(0x11488c8), divmod: 0,...+60 more}
runtime.g0 = runtime.g {stack: (*runtime.stack)(0x1148560), stackguard0: 140702053759432, stackguard1: 140702053759432,...+48 more}
runtime.mcache0 = *runtime.mcache nil
runtime.main_init_done = chan bool 0/0
runtime.mainStarted = true
runtime.runtimeInitTime = 38777141023476
runtime.initSigmask = 0
runtime.badmorestackg0Msg = "fatal: morestack on g0\n"
runtime.badmorestackgsignalMsg = "fatal: morestack on gsignal\n"
runtime.allglock = runtime.mutex {lockRankStruct: runtime.lockRankStruct {}, key: 0}
runtime.allgs = []*runtime.g len: 5, cap: 8, [...]
runtime.allglen = 5
runtime.allgptr = (**runtime.g)(0xc00010e000)
runtime.fastrandseed = 11995571526182586899
runtime.freezing = 0
runtime.worldsema = 1
runtime.gcsema = 1
runtime.earlycgocallback = []uint8 len: 42, cap: 42, [...]
runtime.extram = 0
runtime.extraMCount = 0
runtime.extraMWaiters = 0
runtime.allocmLock = runtime.rwmutex {rLock: (*runtime.mutex)(0x11771e0), readers: 0, readerPass: 0,...+4 more}
runtime.execLock = runtime.rwmutex {rLock: (*runtime.mutex)(0x1177220), readers: 0, readerPass: 0,...+4 more}
runtime.newmHandoff = struct { runtime.lock runtime.mutex; runtime.newm runtime.muintptr; runtime.waiting bool; runtime.wake runtime.note; runtime.haveTemplateThread uint32 } {lock: (*runtime.mutex)(0x1177160), newm: 0, waiting: false,...+2 more}
runtime.pendingPreemptSignals = 0
runtime.prof = struct { runtime.signalLock uint32; runtime.hz int32 } {signalLock: 0, hz: 0}
runtime.forcegcperiod = 120000000000
runtime.starttime = 0
runtime.stealOrder = runtime.randomOrder {count: 8, coprimes: []uint32 len: 4, cap: 4, [...]}
runtime.inittrace = runtime.tracestat {active: false, id: 0, allocs: 0,...+1 more}
runtime.envs = []string len: 39, cap: 39, [...]
runtime.argslice = []string len: 1, cap: 1, [...]
runtime.traceback_cache = 4
runtime.traceback_env = 4
runtime.argc = 1
runtime.argv = (**uint8)(0x7ff7bfeff5f0)
runtime.test_z64 = 3298534883331
runtime.test_x64 = 42
runtime.debug = struct { runtime.cgocheck int32; runtime.clobberfree int32; runtime.efence int32; runtime.gccheckmark int32; runtime.gcpacertrace int32; runtime.gcshrinkstackoff int32; runtime.gcstoptheworld int32; runtime.gctrace int32; runtime.invalidptr int32; runtime.madvdontneed int32; runtime.scavtrace int32; runtime.scheddetail int32; runtime.schedtrace int32; runtime.tracebackancestors int32; runtime.asyncpreemptoff int32; runtime.harddecommit int32; runtime.malloc bool; runtime.allocfreetrace int32; runtime.inittrace int32; runtime.sbrk int32 } {cgocheck: 1, clobberfree: 0, efence: 0,...+17 more}
runtime.dbgvars = []runtime.dbgVar len: 19, cap: 19, [...]
runtime.waitReasonStrings = [27]string [...]
runtime.allm = (*runtime.m)(0xc000080000)
runtime.gomaxprocs = 8
runtime.ncpu = 8
runtime.forcegc = runtime.forcegcstate {lock: (*runtime.mutex)(0x1148300), g: (*runtime.g)(0xc000002680), idle: 1}
runtime.sched = runtime.schedt {goidgen: 48, lastpoll: 38769079268251, pollUntil: 0,...+34 more}
runtime.newprocs = 0
runtime.allpLock = runtime.mutex {lockRankStruct: runtime.lockRankStruct {}, key: 0}
runtime.allp = []*runtime.p len: 8, cap: 8, [...]
runtime.idlepMask = runtime.pMask len: 1, cap: 1, [...]
runtime.timerpMask = runtime.pMask len: 1, cap: 1, [...]
runtime.gcBgMarkWorkerPool = 0
runtime.gcBgMarkWorkerCount = 0
runtime.processorVersionInfo = 526058
runtime.isIntel = true
runtime.islibrary = false
runtime.isarchive = false
runtime.chansendpc = 16795424
runtime.chanrecvpc = 16797984
runtime.semtable = [251]struct { runtime.root runtime.semaRoot; runtime.pad [40]uint8 } [...]
runtime.sigtable = [32]runtime.sigTabT [...]
runtime.fwdSig = [32]uintptr [...]
runtime.handlingSig = [32]uint32 [...]
runtime.signalsOK = true
runtime.sigprofCallers = runtime.cgoCallers [...]
runtime.sigprofCallersUse = 0
runtime.crashing = 0
runtime.testSigtrap = nil
runtime.testSigusr1 = nil
runtime.badginsignalMsg = "fatal: bad g in signal handler\n"
runtime.sigsetAllExiting = 4294967295
runtime.sig = struct { runtime.note runtime.note; runtime.mask [1]uint32; runtime.wanted [1]uint32; runtime.ignored [1]uint32; runtime.recv [1]uint32; runtime.state uint32; runtime.delivering uint32; runtime.inuse bool } {note: (*runtime.note)(0x11771a0), mask: [1]uint32 [...], wanted: [1]uint32 [...],...+5 more}
runtime.class_to_size = [68]uint16 [...]
runtime.class_to_allocnpages = [68]uint8 [...]
runtime.class_to_divmagic = [68]uint32 [...]
runtime.size_to_class8 = [129]uint8 [...]
runtime.size_to_class128 = [249]uint8 [...]
runtime.stackpool = [4]struct { runtime.item runtime.stackpoolItem; runtime._ [40]uint8 } [...]
runtime.stackLarge = struct { runtime.lock runtime.mutex; runtime.free [35]runtime.mSpanList } {lock: (*runtime.mutex)(0x1177ba0), free: [35]runtime.mSpanList [...]}
runtime.maxstacksize = 1000000000
runtime.maxstackceiling = 2000000000
runtime.methodValueCallFrameObjs = [1]runtime.stackObjectRecord [...]
runtime.badsystemstackMsg = "fatal: systemstack called from unexpected goroutine"
runtime.intArgRegs = 9
runtime.pinnedTypemaps = []map[runtime.typeOff]*runtime._type len: 0, cap: 0, nil
runtime.firstmoduledata = runtime.moduledata {pcHeader: (*runtime.pcHeader)(0x10d3ce0), funcnametab: []uint8 len: 49488, cap: 49488, [...], cutab: []uint32 len: 1752, cap: 1752, [...],...+38 more}
runtime.modulesSlice = (*[]*runtime.moduledata)(0xc00000c000)
runtime.faketime = 0
runtime.overrideWrite = nil
runtime.trace = struct { runtime.lock runtime.mutex; runtime.lockOwner *runtime.g; runtime.enabled bool; runtime.shutdown bool; runtime.headerWritten bool; runtime.footerWritten bool; runtime.shutdownSema uint32; runtime.seqStart uint64; runtime.ticksStart int64; runtime.ticksEnd int64; runtime.timeStart int64; runtime.timeEnd int64; runtime.seqGC uint64; runtime.reading runtime.traceBufPtr; runtime.empty runtime.traceBufPtr; runtime.fullHead runtime.traceBufPtr; runtime.fullTail runtime.traceBufPtr; runtime.reader runtime.guintptr; runtime.stackTab runtime.traceStackTable; runtime.stringsLock runtime.mutex; runtime.strings map[string]uint64; runtime.stringSeq uint64; runtime.markWorkerLabels [4]uint64; runtime.bufLock runtime.mutex; runtime.buf runtime.traceBufPtr } {lock: (*runtime.mutex)(0x1150320), lockOwner: *runtime.g nil, enabled: false,...+22 more}
runtime.gStatusStrings = [10]string [...]
runtime.cgoTraceback = unsafe.Pointer(0x0)
runtime.cgoSymbolizer = unsafe.Pointer(0x0)
runtime.reflectOffs = struct { runtime.lock runtime.mutex; runtime.next int32; runtime.m map[int32]unsafe.Pointer; runtime.minv map[unsafe.Pointer]int32 } {lock: (*runtime.mutex)(0x11483e0), next: 0, m: map[int32]unsafe.Pointer nil,...+1 more}
_cgo_init = unsafe.Pointer(0x0)
_cgo_thread_start = unsafe.Pointer(0x0)
_cgo_notify_runtime_init_done = unsafe.Pointer(0x0)
_cgo_callers = unsafe.Pointer(0x0)
_cgo_yield = unsafe.Pointer(0x0)
internal/reflectlite.kindNames = []string len: 27, cap: 27, [...]
unicode.Categories = map[string]*unicode.RangeTable [...]
unicode.Cc = (*unicode.RangeTable)(0x1143440)
unicode.Cf = (*unicode.RangeTable)(0x11449c0)
unicode.Co = (*unicode.RangeTable)(0x1144e80)
unicode.Cs = (*unicode.RangeTable)(0x1141700)
unicode.Nd = (*unicode.RangeTable)(0x1143940)
unicode.L = (*unicode.RangeTable)(0x1141980)
unicode.Lm = (*unicode.RangeTable)(0x1141fc0)
unicode.Lo = (*unicode.RangeTable)(0x11422c0)
unicode.Ll = (*unicode.RangeTable)(0x1141c80)
unicode.M = (*unicode.RangeTable)(0x1142b00)
unicode.Mc = (*unicode.RangeTable)(0x1142e00)
unicode.Me = (*unicode.RangeTable)(0x1143100)
unicode.Mn = (*unicode.RangeTable)(0x1143300)
unicode.Nl = (*unicode.RangeTable)(0x1143cc0)
unicode.No = (*unicode.RangeTable)(0x1144000)
unicode.N = (*unicode.RangeTable)(0x1143640)
unicode.C = (*unicode.RangeTable)(0x1141500)
unicode.Pc = (*unicode.RangeTable)(0x1144680)
unicode.Pd = (*unicode.RangeTable)(0x11448c0)
unicode.Pe = (*unicode.RangeTable)(0x1144bc0)
unicode.Pf = (*unicode.RangeTable)(0x1144c00)
unicode.Pi = (*unicode.RangeTable)(0x1144c40)
unicode.Po = (*unicode.RangeTable)(0x1144c80)
unicode.Ps = (*unicode.RangeTable)(0x1144cc0)
unicode.P = (*unicode.RangeTable)(0x1144380)
unicode.Sc = (*unicode.RangeTable)(0x1144d40)
unicode.Sk = (*unicode.RangeTable)(0x1144d80)
unicode.Sm = (*unicode.RangeTable)(0x1144dc0)
unicode.So = (*unicode.RangeTable)(0x1144e00)
unicode.Z = (*unicode.RangeTable)(0x1144e40)
unicode.S = (*unicode.RangeTable)(0x1144d00)
unicode.Lt = (*unicode.RangeTable)(0x11425c0)
unicode.Lu = (*unicode.RangeTable)(0x1142800)
unicode.Zl = (*unicode.RangeTable)(0x1144ec0)
unicode.Zp = (*unicode.RangeTable)(0x1144f00)
unicode.Zs = (*unicode.RangeTable)(0x1144f40)
unicode.Scripts = map[string]*unicode.RangeTable [...]
unicode.Adlam = (*unicode.RangeTable)(0x1144f80)
unicode.Ahom = (*unicode.RangeTable)(0x1141540)
unicode.Anatolian_Hieroglyphs = (*unicode.RangeTable)(0x1141580)
unicode.Arabic = (*unicode.RangeTable)(0x11415c0)
unicode.Armenian = (*unicode.RangeTable)(0x1141600)
unicode.Avestan = (*unicode.RangeTable)(0x1141640)
unicode.Balinese = (*unicode.RangeTable)(0x1141680)
unicode.Bamum = (*unicode.RangeTable)(0x11416c0)
unicode.Bassa_Vah = (*unicode.RangeTable)(0x1141740)
unicode.Batak = (*unicode.RangeTable)(0x1141780)
unicode.Bengali = (*unicode.RangeTable)(0x11417c0)
unicode.Bhaiksuki = (*unicode.RangeTable)(0x1141800)
unicode.Bopomofo = (*unicode.RangeTable)(0x1141840)
unicode.Brahmi = (*unicode.RangeTable)(0x1141880)
unicode.Braille = (*unicode.RangeTable)(0x11418c0)
unicode.Buginese = (*unicode.RangeTable)(0x1141900)
unicode.Buhid = (*unicode.RangeTable)(0x1141940)
unicode.Canadian_Aboriginal = (*unicode.RangeTable)(0x11419c0)
unicode.Carian = (*unicode.RangeTable)(0x1141a00)
unicode.Caucasian_Albanian = (*unicode.RangeTable)(0x1141a40)
unicode.Chakma = (*unicode.RangeTable)(0x1141a80)
unicode.Cham = (*unicode.RangeTable)(0x1141ac0)
unicode.Cherokee = (*unicode.RangeTable)(0x1141b00)
unicode.Chorasmian = (*unicode.RangeTable)(0x1141b40)
unicode.Common = (*unicode.RangeTable)(0x1141b80)
unicode.Coptic = (*unicode.RangeTable)(0x1141bc0)
unicode.Cuneiform = (*unicode.RangeTable)(0x1141c00)
unicode.Cypriot = (*unicode.RangeTable)(0x1141c40)
unicode.Cyrillic = (*unicode.RangeTable)(0x1141cc0)
unicode.Deseret = (*unicode.RangeTable)(0x1141d00)
unicode.Devanagari = (*unicode.RangeTable)(0x1141d40)
unicode.Dives_Akuru = (*unicode.RangeTable)(0x1141d80)
unicode.Dogra = (*unicode.RangeTable)(0x1141dc0)
unicode.Duployan = (*unicode.RangeTable)(0x1141e00)
unicode.Egyptian_Hieroglyphs = (*unicode.RangeTable)(0x1141e40)
unicode.Elbasan = (*unicode.RangeTable)(0x1141e80)
unicode.Elymaic = (*unicode.RangeTable)(0x1141ec0)
unicode.Ethiopic = (*unicode.RangeTable)(0x1141f00)
unicode.Georgian = (*unicode.RangeTable)(0x1141f40)
unicode.Glagolitic = (*unicode.RangeTable)(0x1141f80)
unicode.Gothic = (*unicode.RangeTable)(0x1142000)
unicode.Grantha = (*unicode.RangeTable)(0x1142040)
unicode.Greek = (*unicode.RangeTable)(0x1142080)
unicode.Gujarati = (*unicode.RangeTable)(0x11420c0)
unicode.Gunjala_Gondi = (*unicode.RangeTable)(0x1142100)
unicode.Gurmukhi = (*unicode.RangeTable)(0x1142140)
unicode.Han = (*unicode.RangeTable)(0x1142180)
unicode.Hangul = (*unicode.RangeTable)(0x11421c0)
unicode.Hanifi_Rohingya = (*unicode.RangeTable)(0x1142200)
unicode.Hanunoo = (*unicode.RangeTable)(0x1142240)
unicode.Hatran = (*unicode.RangeTable)(0x1142280)
unicode.Hebrew = (*unicode.RangeTable)(0x1142300)
unicode.Hiragana = (*unicode.RangeTable)(0x1142340)
unicode.Imperial_Aramaic = (*unicode.RangeTable)(0x1142380)
unicode.Inherited = (*unicode.RangeTable)(0x11423c0)
unicode.Inscriptional_Pahlavi = (*unicode.RangeTable)(0x1142400)
unicode.Inscriptional_Parthian = (*unicode.RangeTable)(0x1142440)
unicode.Javanese = (*unicode.RangeTable)(0x1142480)
unicode.Kaithi = (*unicode.RangeTable)(0x11424c0)
unicode.Kannada = (*unicode.RangeTable)(0x1142500)
unicode.Katakana = (*unicode.RangeTable)(0x1142540)
unicode.Kayah_Li = (*unicode.RangeTable)(0x1142580)
unicode.Kharoshthi = (*unicode.RangeTable)(0x1142600)
unicode.Khitan_Small_Script = (*unicode.RangeTable)(0x1142640)
unicode.Khmer = (*unicode.RangeTable)(0x1142680)
unicode.Khojki = (*unicode.RangeTable)(0x11426c0)
unicode.Khudawadi = (*unicode.RangeTable)(0x1142700)
unicode.Lao = (*unicode.RangeTable)(0x1142740)
unicode.Latin = (*unicode.RangeTable)(0x1142780)
unicode.Lepcha = (*unicode.RangeTable)(0x11427c0)
unicode.Limbu = (*unicode.RangeTable)(0x1142840)
unicode.Linear_A = (*unicode.RangeTable)(0x1142880)
unicode.Linear_B = (*unicode.RangeTable)(0x11428c0)
unicode.Lisu = (*unicode.RangeTable)(0x1142900)
unicode.Lycian = (*unicode.RangeTable)(0x1142940)
unicode.Lydian = (*unicode.RangeTable)(0x1142980)
unicode.Mahajani = (*unicode.RangeTable)(0x11429c0)
unicode.Makasar = (*unicode.RangeTable)(0x1142a00)
unicode.Malayalam = (*unicode.RangeTable)(0x1142a40)
unicode.Mandaic = (*unicode.RangeTable)(0x1142a80)
unicode.Manichaean = (*unicode.RangeTable)(0x1142ac0)
unicode.Marchen = (*unicode.RangeTable)(0x1142b40)
unicode.Masaram_Gondi = (*unicode.RangeTable)(0x1142b80)
unicode.Medefaidrin = (*unicode.RangeTable)(0x1142bc0)
unicode.Meetei_Mayek = (*unicode.RangeTable)(0x1142c00)
unicode.Mende_Kikakui = (*unicode.RangeTable)(0x1142c40)
unicode.Meroitic_Cursive = (*unicode.RangeTable)(0x1142c80)
unicode.Meroitic_Hieroglyphs = (*unicode.RangeTable)(0x1142cc0)
unicode.Miao = (*unicode.RangeTable)(0x1142d00)
unicode.Modi = (*unicode.RangeTable)(0x1142d40)
unicode.Mongolian = (*unicode.RangeTable)(0x1142d80)
unicode.Mro = (*unicode.RangeTable)(0x1142dc0)
unicode.Multani = (*unicode.RangeTable)(0x1142e40)
unicode.Myanmar = (*unicode.RangeTable)(0x1142e80)
unicode.Nabataean = (*unicode.RangeTable)(0x1142ec0)
unicode.Nandinagari = (*unicode.RangeTable)(0x1142f00)
unicode.New_Tai_Lue = (*unicode.RangeTable)(0x1142f40)
unicode.Newa = (*unicode.RangeTable)(0x1142f80)
unicode.Nko = (*unicode.RangeTable)(0x1142fc0)
unicode.Nushu = (*unicode.RangeTable)(0x1143000)
unicode.Nyiakeng_Puachue_Hmong = (*unicode.RangeTable)(0x1143040)
unicode.Ogham = (*unicode.RangeTable)(0x1143080)
unicode.Ol_Chiki = (*unicode.RangeTable)(0x11430c0)
unicode.Old_Hungarian = (*unicode.RangeTable)(0x1143140)
unicode.Old_Italic = (*unicode.RangeTable)(0x1143180)
unicode.Old_North_Arabian = (*unicode.RangeTable)(0x11431c0)
unicode.Old_Permic = (*unicode.RangeTable)(0x1143200)
unicode.Old_Persian = (*unicode.RangeTable)(0x1143240)
unicode.Old_Sogdian = (*unicode.RangeTable)(0x1143280)
unicode.Old_South_Arabian = (*unicode.RangeTable)(0x11432c0)
unicode.Old_Turkic = (*unicode.RangeTable)(0x1143340)
unicode.Oriya = (*unicode.RangeTable)(0x1143380)
unicode.Osage = (*unicode.RangeTable)(0x11433c0)
unicode.Osmanya = (*unicode.RangeTable)(0x1143400)
unicode.Pahawh_Hmong = (*unicode.RangeTable)(0x1143480)
unicode.Palmyrene = (*unicode.RangeTable)(0x11434c0)
unicode.Pau_Cin_Hau = (*unicode.RangeTable)(0x1143500)
unicode.Phags_Pa = (*unicode.RangeTable)(0x1143540)
unicode.Phoenician = (*unicode.RangeTable)(0x1143580)
unicode.Psalter_Pahlavi = (*unicode.RangeTable)(0x11435c0)
unicode.Rejang = (*unicode.RangeTable)(0x1143600)
unicode.Runic = (*unicode.RangeTable)(0x1143680)
unicode.Samaritan = (*unicode.RangeTable)(0x11436c0)
unicode.Saurashtra = (*unicode.RangeTable)(0x1143700)
unicode.Sharada = (*unicode.RangeTable)(0x1143740)
unicode.Shavian = (*unicode.RangeTable)(0x1143780)
unicode.Siddham = (*unicode.RangeTable)(0x11437c0)
unicode.SignWriting = (*unicode.RangeTable)(0x1143800)
unicode.Sinhala = (*unicode.RangeTable)(0x1143840)
unicode.Sogdian = (*unicode.RangeTable)(0x1143880)
unicode.Sora_Sompeng = (*unicode.RangeTable)(0x11438c0)
unicode.Soyombo = (*unicode.RangeTable)(0x1143900)
unicode.Sundanese = (*unicode.RangeTable)(0x1143980)
unicode.Syloti_Nagri = (*unicode.RangeTable)(0x11439c0)
unicode.Syriac = (*unicode.RangeTable)(0x1143a00)
unicode.Tagalog = (*unicode.RangeTable)(0x1143a40)
unicode.Tagbanwa = (*unicode.RangeTable)(0x1143a80)
unicode.Tai_Le = (*unicode.RangeTable)(0x1143ac0)
unicode.Tai_Tham = (*unicode.RangeTable)(0x1143b00)
unicode.Tai_Viet = (*unicode.RangeTable)(0x1143b40)
unicode.Takri = (*unicode.RangeTable)(0x1143b80)
unicode.Tamil = (*unicode.RangeTable)(0x1143bc0)
unicode.Tangut = (*unicode.RangeTable)(0x1143c00)
unicode.Telugu = (*unicode.RangeTable)(0x1143c40)
unicode.Thaana = (*unicode.RangeTable)(0x1143c80)
unicode.Thai = (*unicode.RangeTable)(0x1143d00)
unicode.Tibetan = (*unicode.RangeTable)(0x1143d40)
unicode.Tifinagh = (*unicode.RangeTable)(0x1143d80)
unicode.Tirhuta = (*unicode.RangeTable)(0x1143dc0)
unicode.Ugaritic = (*unicode.RangeTable)(0x1143e00)
unicode.Vai = (*unicode.RangeTable)(0x1143e40)
unicode.Wancho = (*unicode.RangeTable)(0x1143e80)
unicode.Warang_Citi = (*unicode.RangeTable)(0x1143ec0)
unicode.Yezidi = (*unicode.RangeTable)(0x1143f00)
unicode.Yi = (*unicode.RangeTable)(0x1143f40)
unicode.Zanabazar_Square = (*unicode.RangeTable)(0x1143f80)
unicode.Properties = map[string]*unicode.RangeTable [...]
unicode.ASCII_Hex_Digit = (*unicode.RangeTable)(0x1143fc0)
unicode.Bidi_Control = (*unicode.RangeTable)(0x1144040)
unicode.Dash = (*unicode.RangeTable)(0x1144080)
unicode.Deprecated = (*unicode.RangeTable)(0x11440c0)
unicode.Diacritic = (*unicode.RangeTable)(0x1144100)
unicode.Extender = (*unicode.RangeTable)(0x1144140)
unicode.Hex_Digit = (*unicode.RangeTable)(0x1144180)
unicode.Hyphen = (*unicode.RangeTable)(0x11441c0)
unicode.IDS_Binary_Operator = (*unicode.RangeTable)(0x1144200)
unicode.IDS_Trinary_Operator = (*unicode.RangeTable)(0x1144240)
unicode.Ideographic = (*unicode.RangeTable)(0x1144280)
unicode.Join_Control = (*unicode.RangeTable)(0x11442c0)
unicode.Logical_Order_Exception = (*unicode.RangeTable)(0x1144300)
unicode.Noncharacter_Code_Point = (*unicode.RangeTable)(0x1144340)
unicode.Other_Alphabetic = (*unicode.RangeTable)(0x11443c0)
unicode.Other_Default_Ignorable_Code_Point = (*unicode.RangeTable)(0x1144400)
unicode.Other_Grapheme_Extend = (*unicode.RangeTable)(0x1144440)
unicode.Other_ID_Continue = (*unicode.RangeTable)(0x1144480)
unicode.Other_ID_Start = (*unicode.RangeTable)(0x11444c0)
unicode.Other_Lowercase = (*unicode.RangeTable)(0x1144500)
unicode.Other_Math = (*unicode.RangeTable)(0x1144540)
unicode.Other_Uppercase = (*unicode.RangeTable)(0x1144580)
unicode.Pattern_Syntax = (*unicode.RangeTable)(0x11445c0)
unicode.Pattern_White_Space = (*unicode.RangeTable)(0x1144600)
unicode.Prepended_Concatenation_Mark = (*unicode.RangeTable)(0x1144640)
unicode.Quotation_Mark = (*unicode.RangeTable)(0x11446c0)
unicode.Radical = (*unicode.RangeTable)(0x1144700)
unicode.Regional_Indicator = (*unicode.RangeTable)(0x1144740)
unicode.Sentence_Terminal = (*unicode.RangeTable)(0x1144780)
unicode.Soft_Dotted = (*unicode.RangeTable)(0x11447c0)
unicode.Terminal_Punctuation = (*unicode.RangeTable)(0x1144800)
unicode.Unified_Ideograph = (*unicode.RangeTable)(0x1144840)
unicode.Variation_Selector = (*unicode.RangeTable)(0x1144880)
unicode.White_Space = (*unicode.RangeTable)(0x1144900)
unicode.FoldCategory = map[string]*unicode.RangeTable [...]
unicode.foldL = (*unicode.RangeTable)(0x1144940)
unicode.foldLl = (*unicode.RangeTable)(0x1144980)
unicode.foldLt = (*unicode.RangeTable)(0x1144a00)
unicode.foldLu = (*unicode.RangeTable)(0x1144a40)
unicode.foldM = (*unicode.RangeTable)(0x1144a80)
unicode.foldMn = (*unicode.RangeTable)(0x1144ac0)
unicode.FoldScript = map[string]*unicode.RangeTable [...]
unicode.foldCommon = (*unicode.RangeTable)(0x1144b00)
unicode.foldGreek = (*unicode.RangeTable)(0x1144b40)
unicode.foldInherited = (*unicode.RangeTable)(0x1144b80)
errors.errorType = internal/reflectlite.Type(*internal/reflectlite.rtype) 0x1147ef8
unicode/utf8.first = [256]uint8 [...]
unicode/utf8.acceptRanges = [16]unicode/utf8.acceptRange [...]
strconv.optimize = true
strconv.ErrRange = error(*errors.errorString) 0x1148198
strconv.ErrSyntax = error(*errors.errorString) 0x11481a8
strconv.leftcheats = []strconv.leftCheat len: 61, cap: 61, [...]
strconv.detailedPowersOfTen = [696][2]uint64 [...]
strconv.float32info = strconv.floatInfo {mantbits: 23, expbits: 8, bias: -127}
strconv.float64info = strconv.floatInfo {mantbits: 52, expbits: 11, bias: -1023}
strconv.uint64pow10 = [20]uint64 [...]
strconv.isPrint16 = []uint16 len: 434, cap: 434, [...]
strconv.isNotPrint16 = []uint16 len: 132, cap: 132, [...]
strconv.isPrint32 = []uint32 len: 468, cap: 468, [...]
strconv.isNotPrint32 = []uint16 len: 95, cap: 95, [...]
strconv.isGraphic = []uint16 len: 16, cap: 16, [...]
sync/atomic.firstStoreInProgress = 0
sync.expunged = unsafe.Pointer(0xc00008e040)
sync.allPoolsMu = sync.Mutex {state: 0, sema: 0}
sync.allPools = []*sync.Pool len: 0, cap: 0, nil
sync.oldPools = []*sync.Pool len: 0, cap: 0, nil
(dlv) vars /test/
(no vars)
(dlv) vars /^test/
(no vars)
(dlv) vars /^strconv/
(no vars)
(dlv) vars ^strconv
strconv.optimize = true
strconv.ErrRange = error(*errors.errorString) 0x1148198
strconv.ErrSyntax = error(*errors.errorString) 0x11481a8
strconv.leftcheats = []strconv.leftCheat len: 61, cap: 61, [...]
strconv.detailedPowersOfTen = [696][2]uint64 [...]
strconv.float32info = strconv.floatInfo {mantbits: 23, expbits: 8, bias: -127}
strconv.float64info = strconv.floatInfo {mantbits: 52, expbits: 11, bias: -1023}
strconv.uint64pow10 = [20]uint64 [...]
strconv.isPrint16 = []uint16 len: 434, cap: 434, [...]
strconv.isNotPrint16 = []uint16 len: 132, cap: 132, [...]
strconv.isPrint32 = []uint32 len: 468, cap: 468, [...]
strconv.isNotPrint32 = []uint16 len: 95, cap: 95, [...]
strconv.isGraphic = []uint16 len: 16, cap: 16, [...]
(dlv) vars test
internal/testlog.logger = sync/atomic.Value {v: interface {} nil}
runtime.test_z64 = 3298534883331
runtime.test_x64 = 42
runtime.testSigtrap = nil
runtime.testSigusr1 = nil
(dlv) vars main
runtime.main_init_done = chan bool 0/0
runtime.mainStarted = true
(dlv) vars getMax
(no vars)
(dlv) vars getMax*
(no vars)
(dlv) vars getMaxofSmaller
(no vars)
(dlv) n
> main.CanEnd() ./main.go:37 (PC: 0x10ad333)
    32:	                break
    33:	            }            
    34:	        }
    35:	        jmps++
    36:	    }
=>  37:	        return startIdx == end -1 
    38:	}
    39:	
    40:	func getMinOfGreater (arr []int, startIdx , val int) int {
    41:	    min := math.MaxInt
    42:	    next:=-1
(dlv) p startIdx
-1
(dlv) break main.go:37
Breakpoint 11 set at 0x10ad333 for main.CanEnd() ./main.go:37
(dlv) on 11 disp startIdx
(dlv) on 11 print startIdx
(dlv) on 11 print end
(dlv) n
> main.oddEvenJumps() ./main.go:11 (PC: 0x10ad192)
Values returned:
	~r0: false

     6:	)
     7:	
     8:	func oddEvenJumps(arr []int) int {
     9:	    jmps := 0    
    10:	    for i,val := range arr {
=>  11:	        if CanEnd(arr,i+1, val) {
    12:	            jmps++
    13:	        }
    14:	    }
    15:	    
    16:	    return jmps 
(dlv) c
> main.CanEnd() ./main.go:19 (hits goroutine(1):3 total:3) (PC: 0x10ad20a)
    14:	    }
    15:	    
    16:	    return jmps 
    17:	}
    18:	
=>  19:	func CanEnd(arr []int,startIdx, val int) bool {
    20:	    jmps := 1
    21:	    end:=len(arr)
    22:	    
    23:	    for startIdx<end{
    24:	        if jmps % 2 == 1 {
(dlv) c
> main.getMaxofSmaller() ./main.go:52 (hits goroutine(1):3 total:3) (PC: 0x10ad4e0)
    47:	        }
    48:	    }
    49:	    return next
    50:	}
    51:	
=>  52:	func getMaxofSmaller (arr []int, startIdx , val int) int {
    53:	    max := 0
    54:	        next:=-1
    55:	    for i:=startIdx;i < len(arr);i++ {
    56:	        if arr[i]<val && arr[i]>max{
    57:	            max = arr[i]
(dlv) n
> main.getMaxofSmaller() ./main.go:53 (PC: 0x10ad510)
    48:	    }
    49:	    return next
    50:	}
    51:	
    52:	func getMaxofSmaller (arr []int, startIdx , val int) int {
=>  53:	    max := 0
    54:	        next:=-1
    55:	    for i:=startIdx;i < len(arr);i++ {
    56:	        if arr[i]<val && arr[i]>max{
    57:	            max = arr[i]
    58:	            next = i
(dlv) n
> main.getMaxofSmaller() ./main.go:54 (PC: 0x10ad519)
    49:	    return next
    50:	}
    51:	
    52:	func getMaxofSmaller (arr []int, startIdx , val int) int {
    53:	    max := 0
=>  54:	        next:=-1
    55:	    for i:=startIdx;i < len(arr);i++ {
    56:	        if arr[i]<val && arr[i]>max{
    57:	            max = arr[i]
    58:	            next = i
    59:	        }
(dlv) n
> main.getMaxofSmaller() ./main.go:55 (PC: 0x10ad522)
    50:	}
    51:	
    52:	func getMaxofSmaller (arr []int, startIdx , val int) int {
    53:	    max := 0
    54:	        next:=-1
=>  55:	    for i:=startIdx;i < len(arr);i++ {
    56:	        if arr[i]<val && arr[i]>max{
    57:	            max = arr[i]
    58:	            next = i
    59:	        }
    60:	    }
(dlv) n
> main.getMaxofSmaller() ./main.go:56 (PC: 0x10ad545)
    51:	
    52:	func getMaxofSmaller (arr []int, startIdx , val int) int {
    53:	    max := 0
    54:	        next:=-1
    55:	    for i:=startIdx;i < len(arr);i++ {
=>  56:	        if arr[i]<val && arr[i]>max{
    57:	            max = arr[i]
    58:	            next = i
    59:	        }
    60:	    }
    61:	    return next
(dlv) n
> main.getMaxofSmaller() ./main.go:55 (PC: 0x10ad5d5)
    50:	}
    51:	
    52:	func getMaxofSmaller (arr []int, startIdx , val int) int {
    53:	    max := 0
    54:	        next:=-1
=>  55:	    for i:=startIdx;i < len(arr);i++ {
    56:	        if arr[i]<val && arr[i]>max{
    57:	            max = arr[i]
    58:	            next = i
    59:	        }
    60:	    }
(dlv) n
> main.getMaxofSmaller() ./main.go:61 (PC: 0x10ad5eb)
    56:	        if arr[i]<val && arr[i]>max{
    57:	            max = arr[i]
    58:	            next = i
    59:	        }
    60:	    }
=>  61:	    return next
    62:	
    63:	}
    64:	
    65:	func main (){
    66:		fmt.Println(oddEvenJumps([]int{10,13,12,14,15}))
(dlv) n
> main.CanEnd() ./main.go:30 (PC: 0x10ad30c)
Values returned:
	~r0: -1

    25:	            startIdx = getMinOfGreater (arr , startIdx , arr[startIdx])
    26:	            if startIdx == -1{
    27:	                break
    28:	            }
    29:	        }else{
=>  30:	            startIdx = getMaxofSmaller (arr , startIdx , arr[startIdx])
    31:	            if startIdx == -1{
    32:	                break
    33:	            }            
    34:	        }
    35:	        jmps++
(dlv) n
> main.CanEnd() ./main.go:31 (PC: 0x10ad311)
    26:	            if startIdx == -1{
    27:	                break
    28:	            }
    29:	        }else{
    30:	            startIdx = getMaxofSmaller (arr , startIdx , arr[startIdx])
=>  31:	            if startIdx == -1{
    32:	                break
    33:	            }            
    34:	        }
    35:	        jmps++
    36:	    }
(dlv) n
> main.CanEnd() ./main.go:32 (PC: 0x10ad319)
    27:	                break
    28:	            }
    29:	        }else{
    30:	            startIdx = getMaxofSmaller (arr , startIdx , arr[startIdx])
    31:	            if startIdx == -1{
=>  32:	                break
    33:	            }            
    34:	        }
    35:	        jmps++
    36:	    }
    37:	        return startIdx == end -1 
(dlv) n
> main.CanEnd() ./main.go:37 (hits goroutine(1):1 total:1) (PC: 0x10ad333)
	startIdx: -1
	end: 5
    32:	                break
    33:	            }            
    34:	        }
    35:	        jmps++
    36:	    }
=>  37:	        return startIdx == end -1 
    38:	}
    39:	
    40:	func getMinOfGreater (arr []int, startIdx , val int) int {
    41:	    min := math.MaxInt
    42:	    next:=-1
(dlv) n
> main.oddEvenJumps() ./main.go:11 (PC: 0x10ad192)
Values returned:
	~r0: false

     6:	)
     7:	
     8:	func oddEvenJumps(arr []int) int {
     9:	    jmps := 0    
    10:	    for i,val := range arr {
=>  11:	        if CanEnd(arr,i+1, val) {
    12:	            jmps++
    13:	        }
    14:	    }
    15:	    
    16:	    return jmps 
(dlv) n
> main.oddEvenJumps() ./main.go:10 (PC: 0x10ad1af)
     5:		"fmt"
     6:	)
     7:	
     8:	func oddEvenJumps(arr []int) int {
     9:	    jmps := 0    
=>  10:	    for i,val := range arr {
    11:	        if CanEnd(arr,i+1, val) {
    12:	            jmps++
    13:	        }
    14:	    }
    15:	    
(dlv) n
> main.oddEvenJumps() ./main.go:11 (PC: 0x10ad16c)
     6:	)
     7:	
     8:	func oddEvenJumps(arr []int) int {
     9:	    jmps := 0    
    10:	    for i,val := range arr {
=>  11:	        if CanEnd(arr,i+1, val) {
    12:	            jmps++
    13:	        }
    14:	    }
    15:	    
    16:	    return jmps 
(dlv) n
> main.CanEnd() ./main.go:19 (hits goroutine(1):4 total:4) (PC: 0x10ad20a)
    14:	    }
    15:	    
    16:	    return jmps 
    17:	}
    18:	
=>  19:	func CanEnd(arr []int,startIdx, val int) bool {
    20:	    jmps := 1
    21:	    end:=len(arr)
    22:	    
    23:	    for startIdx<end{
    24:	        if jmps % 2 == 1 {
(dlv) n
> main.CanEnd() ./main.go:20 (PC: 0x10ad239)
    15:	    
    16:	    return jmps 
    17:	}
    18:	
    19:	func CanEnd(arr []int,startIdx, val int) bool {
=>  20:	    jmps := 1
    21:	    end:=len(arr)
    22:	    
    23:	    for startIdx<end{
    24:	        if jmps % 2 == 1 {
    25:	            startIdx = getMinOfGreater (arr , startIdx , arr[startIdx])
(dlv) n
> main.CanEnd() ./main.go:21 (PC: 0x10ad242)
    16:	    return jmps 
    17:	}
    18:	
    19:	func CanEnd(arr []int,startIdx, val int) bool {
    20:	    jmps := 1
=>  21:	    end:=len(arr)
    22:	    
    23:	    for startIdx<end{
    24:	        if jmps % 2 == 1 {
    25:	            startIdx = getMinOfGreater (arr , startIdx , arr[startIdx])
    26:	            if startIdx == -1{
(dlv) n
> main.CanEnd() ./main.go:23 (PC: 0x10ad24e)
    18:	
    19:	func CanEnd(arr []int,startIdx, val int) bool {
    20:	    jmps := 1
    21:	    end:=len(arr)
    22:	    
=>  23:	    for startIdx<end{
    24:	        if jmps % 2 == 1 {
    25:	            startIdx = getMinOfGreater (arr , startIdx , arr[startIdx])
    26:	            if startIdx == -1{
    27:	                break
    28:	            }
(dlv) n
> main.CanEnd() ./main.go:24 (PC: 0x10ad25f)
    19:	func CanEnd(arr []int,startIdx, val int) bool {
    20:	    jmps := 1
    21:	    end:=len(arr)
    22:	    
    23:	    for startIdx<end{
=>  24:	        if jmps % 2 == 1 {
    25:	            startIdx = getMinOfGreater (arr , startIdx , arr[startIdx])
    26:	            if startIdx == -1{
    27:	                break
    28:	            }
    29:	        }else{
(dlv) n
> main.CanEnd() ./main.go:25 (PC: 0x10ad27f)
    20:	    jmps := 1
    21:	    end:=len(arr)
    22:	    
    23:	    for startIdx<end{
    24:	        if jmps % 2 == 1 {
=>  25:	            startIdx = getMinOfGreater (arr , startIdx , arr[startIdx])
    26:	            if startIdx == -1{
    27:	                break
    28:	            }
    29:	        }else{
    30:	            startIdx = getMaxofSmaller (arr , startIdx , arr[startIdx])
(dlv) n
> main.CanEnd() ./main.go:26 (PC: 0x10ad2c2)
    21:	    end:=len(arr)
    22:	    
    23:	    for startIdx<end{
    24:	        if jmps % 2 == 1 {
    25:	            startIdx = getMinOfGreater (arr , startIdx , arr[startIdx])
=>  26:	            if startIdx == -1{
    27:	                break
    28:	            }
    29:	        }else{
    30:	            startIdx = getMaxofSmaller (arr , startIdx , arr[startIdx])
    31:	            if startIdx == -1{
(dlv) n
> main.CanEnd() ./main.go:27 (PC: 0x10ad2ca)
    22:	    
    23:	    for startIdx<end{
    24:	        if jmps % 2 == 1 {
    25:	            startIdx = getMinOfGreater (arr , startIdx , arr[startIdx])
    26:	            if startIdx == -1{
=>  27:	                break
    28:	            }
    29:	        }else{
    30:	            startIdx = getMaxofSmaller (arr , startIdx , arr[startIdx])
    31:	            if startIdx == -1{
    32:	                break
(dlv) n
> main.CanEnd() ./main.go:37 (hits goroutine(1):2 total:2) (PC: 0x10ad333)
	startIdx: -1
	end: 5
    32:	                break
    33:	            }            
    34:	        }
    35:	        jmps++
    36:	    }
=>  37:	        return startIdx == end -1 
    38:	}
    39:	
    40:	func getMinOfGreater (arr []int, startIdx , val int) int {
    41:	    min := math.MaxInt
    42:	    next:=-1
(dlv) n
> main.oddEvenJumps() ./main.go:11 (PC: 0x10ad192)
Values returned:
	~r0: false

     6:	)
     7:	
     8:	func oddEvenJumps(arr []int) int {
     9:	    jmps := 0    
    10:	    for i,val := range arr {
=>  11:	        if CanEnd(arr,i+1, val) {
    12:	            jmps++
    13:	        }
    14:	    }
    15:	    
    16:	    return jmps 
(dlv) n
> main.oddEvenJumps() ./main.go:10 (PC: 0x10ad1af)
     5:		"fmt"
     6:	)
     7:	
     8:	func oddEvenJumps(arr []int) int {
     9:	    jmps := 0    
=>  10:	    for i,val := range arr {
    11:	        if CanEnd(arr,i+1, val) {
    12:	            jmps++
    13:	        }
    14:	    }
    15:	    
(dlv) n
> main.oddEvenJumps() ./main.go:11 (PC: 0x10ad16c)
     6:	)
     7:	
     8:	func oddEvenJumps(arr []int) int {
     9:	    jmps := 0    
    10:	    for i,val := range arr {
=>  11:	        if CanEnd(arr,i+1, val) {
    12:	            jmps++
    13:	        }
    14:	    }
    15:	    
    16:	    return jmps 
(dlv) n
> main.CanEnd() ./main.go:19 (hits goroutine(1):5 total:5) (PC: 0x10ad20a)
    14:	    }
    15:	    
    16:	    return jmps 
    17:	}
    18:	
=>  19:	func CanEnd(arr []int,startIdx, val int) bool {
    20:	    jmps := 1
    21:	    end:=len(arr)
    22:	    
    23:	    for startIdx<end{
    24:	        if jmps % 2 == 1 {
(dlv) n
> main.CanEnd() ./main.go:20 (PC: 0x10ad239)
    15:	    
    16:	    return jmps 
    17:	}
    18:	
    19:	func CanEnd(arr []int,startIdx, val int) bool {
=>  20:	    jmps := 1
    21:	    end:=len(arr)
    22:	    
    23:	    for startIdx<end{
    24:	        if jmps % 2 == 1 {
    25:	            startIdx = getMinOfGreater (arr , startIdx , arr[startIdx])
(dlv) n
> main.CanEnd() ./main.go:21 (PC: 0x10ad242)
    16:	    return jmps 
    17:	}
    18:	
    19:	func CanEnd(arr []int,startIdx, val int) bool {
    20:	    jmps := 1
=>  21:	    end:=len(arr)
    22:	    
    23:	    for startIdx<end{
    24:	        if jmps % 2 == 1 {
    25:	            startIdx = getMinOfGreater (arr , startIdx , arr[startIdx])
    26:	            if startIdx == -1{
(dlv) n
> main.CanEnd() ./main.go:23 (PC: 0x10ad24e)
    18:	
    19:	func CanEnd(arr []int,startIdx, val int) bool {
    20:	    jmps := 1
    21:	    end:=len(arr)
    22:	    
=>  23:	    for startIdx<end{
    24:	        if jmps % 2 == 1 {
    25:	            startIdx = getMinOfGreater (arr , startIdx , arr[startIdx])
    26:	            if startIdx == -1{
    27:	                break
    28:	            }
(dlv) n
> main.CanEnd() ./main.go:37 (hits goroutine(1):3 total:3) (PC: 0x10ad333)
	startIdx: 5
	end: 5
    32:	                break
    33:	            }            
    34:	        }
    35:	        jmps++
    36:	    }
=>  37:	        return startIdx == end -1 
    38:	}
    39:	
    40:	func getMinOfGreater (arr []int, startIdx , val int) int {
    41:	    min := math.MaxInt
    42:	    next:=-1
(dlv) n
> main.oddEvenJumps() ./main.go:11 (PC: 0x10ad192)
Values returned:
	~r0: false

     6:	)
     7:	
     8:	func oddEvenJumps(arr []int) int {
     9:	    jmps := 0    
    10:	    for i,val := range arr {
=>  11:	        if CanEnd(arr,i+1, val) {
    12:	            jmps++
    13:	        }
    14:	    }
    15:	    
    16:	    return jmps 
(dlv) n
> main.oddEvenJumps() ./main.go:10 (PC: 0x10ad1af)
     5:		"fmt"
     6:	)
     7:	
     8:	func oddEvenJumps(arr []int) int {
     9:	    jmps := 0    
=>  10:	    for i,val := range arr {
    11:	        if CanEnd(arr,i+1, val) {
    12:	            jmps++
    13:	        }
    14:	    }
    15:	    
(dlv) n
> main.oddEvenJumps() ./main.go:16 (PC: 0x10ad1be)
    11:	        if CanEnd(arr,i+1, val) {
    12:	            jmps++
    13:	        }
    14:	    }
    15:	    
=>  16:	    return jmps 
    17:	}
    18:	
    19:	func CanEnd(arr []int,startIdx, val int) bool {
    20:	    jmps := 1
    21:	    end:=len(arr)
(dlv) n
> main.main() ./main.go:66 (PC: 0x10ad6d3)
Values returned:
	~r0: 0

    61:	    return next
    62:	
    63:	}
    64:	
    65:	func main (){
=>  66:		fmt.Println(oddEvenJumps([]int{10,13,12,14,15}))
    67:	}
(dlv) n
> main.main() ./main.go:67 (PC: 0x10ad757)
    62:	
    63:	}
    64:	
    65:	func main (){
    66:		fmt.Println(oddEvenJumps([]int{10,13,12,14,15}))
=>  67:	}
(dlv) n
> runtime.main() /usr/local/go/src/runtime/proc.go:259 (PC: 0x1036658)
Warning: debugging optimized function
Values returned:

   254:	
   255:		// Make racy client program work: if panicking on
   256:		// another goroutine at the same time as main returns,
   257:		// let the other goroutine finish printing the panic trace.
   258:		// Once it does, it will exit. See issues 3934 and 20018.
=> 259:		if atomic.Load(&runningPanicDefers) != 0 {
   260:			// Running deferred functions should not take long.
   261:			for c := 0; c < 1000; c++ {
   262:				if atomic.Load(&runningPanicDefers) == 0 {
   263:					break
   264:				}
(dlv) c
(dlv) c
(dlv) r
Process restarted with PID 45304
(dlv) c
> runtime.main() /usr/local/go/src/runtime/proc.go:145 (hits goroutine(1):1 total:1) (PC: 0x103648a)
Warning: debugging optimized function
   140:	
   141:	// Value to use for signal mask for newly created M's.
   142:	var initSigmask sigset
   143:	
   144:	// The main goroutine.
=> 145:	func main() {
   146:		g := getg()
   147:	
   148:		// Racectx of m0->g0 is used only as the parent of the main goroutine.
   149:		// It must not be used for anything else.
   150:		g.m.g0.racectx = 0
(dlv) clearall
Breakpoint 1 cleared at 0x1036446,0x10364e8 for (multiple functions)() /usr/local/go/src/runtime/proc.go:170
Breakpoint 2 cleared at 0x103648a for runtime.main() /usr/local/go/src/runtime/proc.go:145
Breakpoint 3 cleared at 0x103655c,0x1036786 for (multiple functions)() /usr/local/go/src/runtime/proc.go:203
Breakpoint 4 cleared at 0x10ad0ca for main.oddEvenJumps() ./main.go:8
Breakpoint 5 cleared at 0x10ad20a for main.CanEnd() ./main.go:19
Breakpoint 7 cleared at 0x10ad4e0 for main.getMaxofSmaller() ./main.go:52
Breakpoint 8 cleared at 0x10ad62f for main.main() ./main.go:65
Breakpoint 11 cleared at 0x10ad333 for main.CanEnd() ./main.go:37
(dlv) c
(dlv) break main.go:20
(dlv) break main.go:37
(dlv) r
Process restarted with PID 45697
(dlv) break main.go:37
Breakpoint 1 set at 0x10ad333 for main.CanEnd() ./main.go:37
(dlv) on 1 print end
(dlv) on 1 print startIdx
(dlv) break main.go:45
Breakpoint 2 set at 0x10ad473 for main.getMinOfGreater() ./main.go:45
(dlv) on 2 print min
(dlv) on 2 print next
(dlv) break main.go:58
Breakpoint 3 set at 0x10ad5c9 for main.getMaxofSmaller() ./main.go:58
(dlv) on 3 print max
(dlv) on 3 print next
(dlv) c
> main.getMinOfGreater() ./main.go:45 (hits goroutine(1):1 total:1) (PC: 0x10ad473)
	min: 9223372036854775807
	next: -1
    40:	func getMinOfGreater (arr []int, startIdx , val int) int {
    41:	    min := math.MaxInt
    42:	    next:=-1
    43:	    for i:=startIdx;i < len(arr);i++ {
    44:	        if arr[i]>val && arr[i]<min{
=>  45:	            min = arr[i]
    46:	            next = i
    47:	        }
    48:	    }
    49:	    return next
    50:	}
(dlv) n
> main.getMinOfGreater() ./main.go:46 (PC: 0x10ad495)
    41:	    min := math.MaxInt
    42:	    next:=-1
    43:	    for i:=startIdx;i < len(arr);i++ {
    44:	        if arr[i]>val && arr[i]<min{
    45:	            min = arr[i]
=>  46:	            next = i
    47:	        }
    48:	    }
    49:	    return next
    50:	}
    51:	
(dlv) n
> main.getMinOfGreater() ./main.go:43 (PC: 0x10ad3f4)
    38:	}
    39:	
    40:	func getMinOfGreater (arr []int, startIdx , val int) int {
    41:	    min := math.MaxInt
    42:	    next:=-1
=>  43:	    for i:=startIdx;i < len(arr);i++ {
    44:	        if arr[i]>val && arr[i]<min{
    45:	            min = arr[i]
    46:	            next = i
    47:	        }
    48:	    }
(dlv) n
> main.getMinOfGreater() ./main.go:44 (PC: 0x10ad40c)
    39:	
    40:	func getMinOfGreater (arr []int, startIdx , val int) int {
    41:	    min := math.MaxInt
    42:	    next:=-1
    43:	    for i:=startIdx;i < len(arr);i++ {
=>  44:	        if arr[i]>val && arr[i]<min{
    45:	            min = arr[i]
    46:	            next = i
    47:	        }
    48:	    }
    49:	    return next
(dlv) n
> main.getMinOfGreater() ./main.go:43 (PC: 0x10ad4a2)
    38:	}
    39:	
    40:	func getMinOfGreater (arr []int, startIdx , val int) int {
    41:	    min := math.MaxInt
    42:	    next:=-1
=>  43:	    for i:=startIdx;i < len(arr);i++ {
    44:	        if arr[i]>val && arr[i]<min{
    45:	            min = arr[i]
    46:	            next = i
    47:	        }
    48:	    }
(dlv) n
> main.getMinOfGreater() ./main.go:49 (PC: 0x10ad4b8)
    44:	        if arr[i]>val && arr[i]<min{
    45:	            min = arr[i]
    46:	            next = i
    47:	        }
    48:	    }
=>  49:	    return next
    50:	}
    51:	
    52:	func getMaxofSmaller (arr []int, startIdx , val int) int {
    53:	    max := 0
    54:	        next:=-1
(dlv) n
> main.CanEnd() ./main.go:25 (PC: 0x10ad2bd)
Values returned:
	~r0: 3

    20:	    jmps := 1
    21:	    end:=len(arr)
    22:	    
    23:	    for startIdx<end{
    24:	        if jmps % 2 == 1 {
=>  25:	            startIdx = getMinOfGreater (arr , startIdx , arr[startIdx])
    26:	            if startIdx == -1{
    27:	                break
    28:	            }
    29:	        }else{
    30:	            startIdx = getMaxofSmaller (arr , startIdx , arr[startIdx])
(dlv) n
> main.CanEnd() ./main.go:26 (PC: 0x10ad2c2)
    21:	    end:=len(arr)
    22:	    
    23:	    for startIdx<end{
    24:	        if jmps % 2 == 1 {
    25:	            startIdx = getMinOfGreater (arr , startIdx , arr[startIdx])
=>  26:	            if startIdx == -1{
    27:	                break
    28:	            }
    29:	        }else{
    30:	            startIdx = getMaxofSmaller (arr , startIdx , arr[startIdx])
    31:	            if startIdx == -1{
(dlv) n
> main.CanEnd() ./main.go:35 (PC: 0x10ad2cc)
    30:	            startIdx = getMaxofSmaller (arr , startIdx , arr[startIdx])
    31:	            if startIdx == -1{
    32:	                break
    33:	            }            
    34:	        }
=>  35:	        jmps++
    36:	    }
    37:	        return startIdx == end -1 
    38:	}
    39:	
    40:	func getMinOfGreater (arr []int, startIdx , val int) int {
(dlv) n
> main.CanEnd() ./main.go:23 (PC: 0x10ad24e)
    18:	
    19:	func CanEnd(arr []int,startIdx, val int) bool {
    20:	    jmps := 1
    21:	    end:=len(arr)
    22:	    
=>  23:	    for startIdx<end{
    24:	        if jmps % 2 == 1 {
    25:	            startIdx = getMinOfGreater (arr , startIdx , arr[startIdx])
    26:	            if startIdx == -1{
    27:	                break
    28:	            }
(dlv) n
> main.CanEnd() ./main.go:24 (PC: 0x10ad25f)
    19:	func CanEnd(arr []int,startIdx, val int) bool {
    20:	    jmps := 1
    21:	    end:=len(arr)
    22:	    
    23:	    for startIdx<end{
=>  24:	        if jmps % 2 == 1 {
    25:	            startIdx = getMinOfGreater (arr , startIdx , arr[startIdx])
    26:	            if startIdx == -1{
    27:	                break
    28:	            }
    29:	        }else{
(dlv) n
> main.CanEnd() ./main.go:30 (PC: 0x10ad2ce)
    25:	            startIdx = getMinOfGreater (arr , startIdx , arr[startIdx])
    26:	            if startIdx == -1{
    27:	                break
    28:	            }
    29:	        }else{
=>  30:	            startIdx = getMaxofSmaller (arr , startIdx , arr[startIdx])
    31:	            if startIdx == -1{
    32:	                break
    33:	            }            
    34:	        }
    35:	        jmps++
(dlv) n
> main.CanEnd() ./main.go:31 (PC: 0x10ad311)
    26:	            if startIdx == -1{
    27:	                break
    28:	            }
    29:	        }else{
    30:	            startIdx = getMaxofSmaller (arr , startIdx , arr[startIdx])
=>  31:	            if startIdx == -1{
    32:	                break
    33:	            }            
    34:	        }
    35:	        jmps++
    36:	    }
(dlv) n
> main.CanEnd() ./main.go:32 (PC: 0x10ad319)
    27:	                break
    28:	            }
    29:	        }else{
    30:	            startIdx = getMaxofSmaller (arr , startIdx , arr[startIdx])
    31:	            if startIdx == -1{
=>  32:	                break
    33:	            }            
    34:	        }
    35:	        jmps++
    36:	    }
    37:	        return startIdx == end -1 
(dlv) n
> main.CanEnd() ./main.go:37 (hits goroutine(1):1 total:1) (PC: 0x10ad333)
	end: 5
	startIdx: -1
    32:	                break
    33:	            }            
    34:	        }
    35:	        jmps++
    36:	    }
=>  37:	        return startIdx == end -1 
    38:	}
    39:	
    40:	func getMinOfGreater (arr []int, startIdx , val int) int {
    41:	    min := math.MaxInt
    42:	    next:=-1
(dlv) 
> main.oddEvenJumps() ./main.go:11 (PC: 0x10ad192)
Values returned:
	~r0: false

     6:	)
     7:	
     8:	func oddEvenJumps(arr []int) int {
     9:	    jmps := 0    
    10:	    for i,val := range arr {
=>  11:	        if CanEnd(arr,i+1, val) {
    12:	            jmps++
    13:	        }
    14:	    }
    15:	    
    16:	    return jmps 
(dlv) n
> main.oddEvenJumps() ./main.go:10 (PC: 0x10ad1af)
     5:		"fmt"
     6:	)
     7:	
     8:	func oddEvenJumps(arr []int) int {
     9:	    jmps := 0    
=>  10:	    for i,val := range arr {
    11:	        if CanEnd(arr,i+1, val) {
    12:	            jmps++
    13:	        }
    14:	    }
    15:	    
(dlv) n
> main.oddEvenJumps() ./main.go:11 (PC: 0x10ad16c)
     6:	)
     7:	
     8:	func oddEvenJumps(arr []int) int {
     9:	    jmps := 0    
    10:	    for i,val := range arr {
=>  11:	        if CanEnd(arr,i+1, val) {
    12:	            jmps++
    13:	        }
    14:	    }
    15:	    
    16:	    return jmps 
(dlv) n
> main.getMinOfGreater() ./main.go:45 (hits goroutine(1):2 total:2) (PC: 0x10ad473)
	min: 9223372036854775807
	next: -1
    40:	func getMinOfGreater (arr []int, startIdx , val int) int {
    41:	    min := math.MaxInt
    42:	    next:=-1
    43:	    for i:=startIdx;i < len(arr);i++ {
    44:	        if arr[i]>val && arr[i]<min{
=>  45:	            min = arr[i]
    46:	            next = i
    47:	        }
    48:	    }
    49:	    return next
    50:	}
(dlv) n
> main.getMinOfGreater() ./main.go:46 (PC: 0x10ad495)
    41:	    min := math.MaxInt
    42:	    next:=-1
    43:	    for i:=startIdx;i < len(arr);i++ {
    44:	        if arr[i]>val && arr[i]<min{
    45:	            min = arr[i]
=>  46:	            next = i
    47:	        }
    48:	    }
    49:	    return next
    50:	}
    51:	
(dlv) n
> main.getMinOfGreater() ./main.go:43 (PC: 0x10ad3f4)
    38:	}
    39:	
    40:	func getMinOfGreater (arr []int, startIdx , val int) int {
    41:	    min := math.MaxInt
    42:	    next:=-1
=>  43:	    for i:=startIdx;i < len(arr);i++ {
    44:	        if arr[i]>val && arr[i]<min{
    45:	            min = arr[i]
    46:	            next = i
    47:	        }
    48:	    }
(dlv) n
> main.getMinOfGreater() ./main.go:44 (PC: 0x10ad40c)
    39:	
    40:	func getMinOfGreater (arr []int, startIdx , val int) int {
    41:	    min := math.MaxInt
    42:	    next:=-1
    43:	    for i:=startIdx;i < len(arr);i++ {
=>  44:	        if arr[i]>val && arr[i]<min{
    45:	            min = arr[i]
    46:	            next = i
    47:	        }
    48:	    }
    49:	    return next
(dlv) n
> main.getMinOfGreater() ./main.go:43 (PC: 0x10ad4a2)
    38:	}
    39:	
    40:	func getMinOfGreater (arr []int, startIdx , val int) int {
    41:	    min := math.MaxInt
    42:	    next:=-1
=>  43:	    for i:=startIdx;i < len(arr);i++ {
    44:	        if arr[i]>val && arr[i]<min{
    45:	            min = arr[i]
    46:	            next = i
    47:	        }
    48:	    }
(dlv) n
> main.getMinOfGreater() ./main.go:49 (PC: 0x10ad4b8)
    44:	        if arr[i]>val && arr[i]<min{
    45:	            min = arr[i]
    46:	            next = i
    47:	        }
    48:	    }
=>  49:	    return next
    50:	}
    51:	
    52:	func getMaxofSmaller (arr []int, startIdx , val int) int {
    53:	    max := 0
    54:	        next:=-1
(dlv) n
> main.CanEnd() ./main.go:25 (PC: 0x10ad2bd)
Values returned:
	~r0: 3

    20:	    jmps := 1
    21:	    end:=len(arr)
    22:	    
    23:	    for startIdx<end{
    24:	        if jmps % 2 == 1 {
=>  25:	            startIdx = getMinOfGreater (arr , startIdx , arr[startIdx])
    26:	            if startIdx == -1{
    27:	                break
    28:	            }
    29:	        }else{
    30:	            startIdx = getMaxofSmaller (arr , startIdx , arr[startIdx])
(dlv) p startIdx
2
(dlv) n
> main.CanEnd() ./main.go:26 (PC: 0x10ad2c2)
    21:	    end:=len(arr)
    22:	    
    23:	    for startIdx<end{
    24:	        if jmps % 2 == 1 {
    25:	            startIdx = getMinOfGreater (arr , startIdx , arr[startIdx])
=>  26:	            if startIdx == -1{
    27:	                break
    28:	            }
    29:	        }else{
    30:	            startIdx = getMaxofSmaller (arr , startIdx , arr[startIdx])
    31:	            if startIdx == -1{
(dlv) n
> main.CanEnd() ./main.go:35 (PC: 0x10ad2cc)
    30:	            startIdx = getMaxofSmaller (arr , startIdx , arr[startIdx])
    31:	            if startIdx == -1{
    32:	                break
    33:	            }            
    34:	        }
=>  35:	        jmps++
    36:	    }
    37:	        return startIdx == end -1 
    38:	}
    39:	
    40:	func getMinOfGreater (arr []int, startIdx , val int) int {
(dlv) n
> main.CanEnd() ./main.go:23 (PC: 0x10ad24e)
    18:	
    19:	func CanEnd(arr []int,startIdx, val int) bool {
    20:	    jmps := 1
    21:	    end:=len(arr)
    22:	    
=>  23:	    for startIdx<end{
    24:	        if jmps % 2 == 1 {
    25:	            startIdx = getMinOfGreater (arr , startIdx , arr[startIdx])
    26:	            if startIdx == -1{
    27:	                break
    28:	            }
(dlv) n
> main.CanEnd() ./main.go:24 (PC: 0x10ad25f)
    19:	func CanEnd(arr []int,startIdx, val int) bool {
    20:	    jmps := 1
    21:	    end:=len(arr)
    22:	    
    23:	    for startIdx<end{
=>  24:	        if jmps % 2 == 1 {
    25:	            startIdx = getMinOfGreater (arr , startIdx , arr[startIdx])
    26:	            if startIdx == -1{
    27:	                break
    28:	            }
    29:	        }else{
(dlv) n
> main.CanEnd() ./main.go:30 (PC: 0x10ad2ce)
    25:	            startIdx = getMinOfGreater (arr , startIdx , arr[startIdx])
    26:	            if startIdx == -1{
    27:	                break
    28:	            }
    29:	        }else{
=>  30:	            startIdx = getMaxofSmaller (arr , startIdx , arr[startIdx])
    31:	            if startIdx == -1{
    32:	                break
    33:	            }            
    34:	        }
    35:	        jmps++
(dlv) n
> main.CanEnd() ./main.go:31 (PC: 0x10ad311)
    26:	            if startIdx == -1{
    27:	                break
    28:	            }
    29:	        }else{
    30:	            startIdx = getMaxofSmaller (arr , startIdx , arr[startIdx])
=>  31:	            if startIdx == -1{
    32:	                break
    33:	            }            
    34:	        }
    35:	        jmps++
    36:	    }
(dlv) n
> main.CanEnd() ./main.go:32 (PC: 0x10ad319)
    27:	                break
    28:	            }
    29:	        }else{
    30:	            startIdx = getMaxofSmaller (arr , startIdx , arr[startIdx])
    31:	            if startIdx == -1{
=>  32:	                break
    33:	            }            
    34:	        }
    35:	        jmps++
    36:	    }
    37:	        return startIdx == end -1 
(dlv) p startIdx
-1
(dlv) locals
jmps = 2
end = 5
(dlv) vars
fmt.ppFree = sync.Pool {noCopy: sync.noCopy {}, local: unsafe.Pointer(0x0), localSize: 0,...+3 more}
fmt.complexError = error(*errors.errorString) 0x1147f18
fmt.boolError = error(*errors.errorString) 0x1147f08
math.useFMA = true
os.ErrInvalid = error(*errors.errorString) 0x11480d8
os.ErrPermission = error(*errors.errorString) 0x1148108
os.ErrExist = error(*errors.errorString) 0x11480c8
os.ErrNotExist = error(*errors.errorString) 0x11480f8
os.ErrClosed = error(*errors.errorString) 0x11480a8
os.ErrNoDeadline = error(*errors.errorString) 0x11480e8
os.ErrDeadlineExceeded = error(*internal/poll.DeadlineExceededError) 0x11480b8
os.ErrProcessDone = error(*errors.errorString) 0x1148118
os.executablePath = "/Users/ramesh/Documents/Repos/go/src/going_in_circles/go/test/__...+9 more"
os.initCwd = "/Users/ramesh/Documents/Repos/go/src/going_in_circles/go/test"
os.initCwdErr = error nil
os.Stdin = (*os.File)(0xc0000b4000)
os.Stdout = (*os.File)(0xc0000b4008)
os.Stderr = (*os.File)(0xc0000b4010)
os.errWriteAtInAppendMode = error(*errors.errorString) 0x1148138
os.Args = []string len: 1, cap: 1, [...]
os.errPatternHasSeparator = error(*errors.errorString) 0x1148128
internal/poll.errEAGAIN = error(syscall.Errno) EAGAIN (35)
internal/poll.errEINVAL = error(syscall.Errno) EINVAL (22)
internal/poll.errENOENT = error(syscall.Errno) ENOENT (2)
internal/poll.ErrFileClosing = error(*errors.errorString) 0x1147f78
internal/poll.ErrNoDeadline = error(*errors.errorString) 0x1147f88
internal/poll.ErrDeadlineExceeded = error(*internal/poll.DeadlineExceededError) 0x1141098
internal/poll.ErrNotPollable = error(*errors.errorString) 0x1147f98
internal/poll.serverInit = sync.Once {done: 0, m: (*sync.Mutex)(0x117703c)}
internal/poll.CloseFunc = syscall.Close
internal/cpu.DebugOptions = true
internal/cpu.CacheLineSize = 64
internal/cpu.X86 = struct { internal/cpu._ internal/cpu.CacheLinePad; HasAES bool; HasADX bool; HasAVX bool; HasAVX2 bool; HasBMI1 bool; HasBMI2 bool; HasERMS bool; HasFMA bool; HasOSXSAVE bool; HasPCLMULQDQ bool; HasPOPCNT bool; HasRDTSCP bool; HasSSE3 bool; HasSSSE3 bool; HasSSE41 bool; HasSSE42 bool; internal/cpu._ internal/cpu.CacheLinePad } {_: (*"internal/cpu.CacheLinePad")(0x11774a0), HasAES: true, HasADX: true,...+15 more}
internal/cpu.options = []internal/cpu.option len: 15, cap: 15, [...]
internal/cpu.maxExtendedFunctionInformation = 2147483656
internal/testlog.logger = sync/atomic.Value {v: interface {} nil}
io/fs.ErrInvalid = error(*errors.errorString) 0x1148068
io/fs.ErrPermission = error(*errors.errorString) 0x1148088
io/fs.ErrExist = error(*errors.errorString) 0x1148058
io/fs.ErrNotExist = error(*errors.errorString) 0x1148078
io/fs.ErrClosed = error(*errors.errorString) 0x1148048
io/fs.SkipDir = error(*errors.errorString) 0x1148098
path.ErrBadPattern = error(*errors.errorString) 0x1148178
time.std0x = [6]int [...]
time.longDayNames = []string len: 7, cap: 7, [...]
time.longMonthNames = []string len: 12, cap: 12, [...]
time.atoiError = error(*errors.errorString) 0x11481b8
time.errBad = error(*errors.errorString) 0x11481d8
time.errLeadingInt = error(*errors.errorString) 0x11481e8
time.unitMap = map[string]uint64 [...]
time.daysBefore = [13]int32 [...]
time.startNano = 40571063070647
time.UTC = (*time.Location)(0x1145040)
time.utcLoc = time.Location {name: "UTC", zone: []time.zone len: 0, cap: 0, nil, tx: []time.zoneTrans len: 0, cap: 0, nil,...+4 more}
time.Local = (*time.Location)(0x11484e0)
time.localLoc = time.Location {name: "", zone: []time.zone len: 0, cap: 0, nil, tx: []time.zoneTrans len: 0, cap: 0, nil,...+4 more}
time.localOnce = sync.Once {done: 0, m: (*sync.Mutex)(0x117705c)}
time.errLocation = error(*errors.errorString) 0x11481f8
time.loadFromEmbeddedTZData = nil
time.badData = error(*errors.errorString) 0x11481c8
time.loadTzinfoFromTzdata = nil
time.zoneSources = []string len: 4, cap: 4, [...]
syscall.envOnce = sync.Once {done: 1, m: (*sync.Mutex)(0x117704c)}
syscall.envLock = sync.RWMutex {w: (*sync.Mutex)(0x11770c0), writerSem: 0, readerSem: 0,...+2 more}
syscall.env = map[string]int [...]
syscall.envs = []string len: 39, cap: 40, [...]
syscall.execveDarwin = syscall.execve
syscall.minRoutingSockaddrLen = 4
syscall._zero = 0
syscall.Stdin = 0
syscall.Stdout = 1
syscall.Stderr = 2
syscall.errEAGAIN = error(syscall.Errno) EAGAIN (35)
syscall.errEINVAL = error(syscall.Errno) EINVAL (22)
syscall.errENOENT = error(syscall.Errno) ENOENT (2)
syscall.errors = [106]string [...]
internal/oserror.ErrInvalid = error(*errors.errorString) 0x1147f48
internal/oserror.ErrPermission = error(*errors.errorString) 0x1147f68
internal/oserror.ErrExist = error(*errors.errorString) 0x1147f38
internal/oserror.ErrNotExist = error(*errors.errorString) 0x1147f58
internal/oserror.ErrClosed = error(*errors.errorString) 0x1147f28
io.ErrShortWrite = error(*errors.errorString) 0x1147ff8
io.errInvalidWrite = error(*errors.errorString) 0x1148018
io.ErrShortBuffer = error(*errors.errorString) 0x1147fe8
io.EOF = error(*errors.errorString) 0x1147fb8
io.ErrUnexpectedEOF = error(*errors.errorString) 0x1148008
io.ErrNoProgress = error(*errors.errorString) 0x1147fd8
io.errWhence = error(*errors.errorString) 0x1148038
io.errOffset = error(*errors.errorString) 0x1148028
io.ErrClosedPipe = error(*errors.errorString) 0x1147fc8
internal/bytealg.MaxLen = 63
reflect.intArgRegs = 9
reflect.floatArgRegs = 15
reflect.floatRegSize = 8
reflect.kindNames = []string len: 27, cap: 27, [...]
reflect.layoutCache = sync.Map {mu: (*sync.Mutex)(0x1148420), read: (*"sync/atomic.Value")(0x1148428), dirty: map[interface {}]*sync.entry nil,...+1 more}
reflect.uint8Type = (*reflect.rtype)(0x10b50e0)
reflect.stringType = (*reflect.rtype)(0x10b4fa0)
reflect.dummy = struct { reflect.b bool; reflect.x interface {} } {b: false, x: interface {} nil}
runtime.useAeshash = true
runtime.aeskeysched = [128]uint8 [...]
runtime.hashkey = [4]uintptr [...]
runtime.iscgo = false
runtime.cgoHasExtraM = false
runtime.cgo_yield = (*unsafe.Pointer)(0x1147dc0)
runtime.ncgocall = 0
runtime.x86HasPOPCNT = true
runtime.x86HasSSE41 = true
runtime.x86HasFMA = true
runtime.useAVXmemmove = true
runtime.cpuprof = runtime.cpuProfile {lock: (*runtime.mutex)(0x114a4e0), on: false, log: *runtime.profBuf nil,...+4 more}
runtime._cgo_setenv = unsafe.Pointer(0x0)
runtime._cgo_unsetenv = unsafe.Pointer(0x0)
runtime.boundsErrorFmts = [9]string [...]
runtime.boundsNegErrorFmts = [8]string [...]
runtime.defaultGOROOT = "/usr/local/go"
runtime.buildVersion = "go1.18.2"
runtime.fastlog2Table = [33]float64 [...]
runtime.inf = +Inf
runtime.itabLock = runtime.mutex {lockRankStruct: runtime.lockRankStruct {}, key: 0}
runtime.itabTable = (*runtime.itabTableType)(0x1146d80)
runtime.itabTableInit = runtime.itabTableType {size: 512, count: 14, entries: [512]*runtime.itab [...]}
runtime.uint16Eface = (unreadable could not resolve interface type)
runtime.uint32Eface = (unreadable could not resolve interface type)
runtime.uint64Eface = (unreadable could not resolve interface type)
runtime.stringEface = (unreadable could not resolve interface type)
runtime.sliceEface = (unreadable could not resolve interface type)
runtime.uint16Type = (*runtime._type)(0x10b4ee0)
runtime.uint32Type = (*runtime._type)(0x10b4f20)
runtime.uint64Type = (*runtime._type)(0x10b4f60)
runtime.stringType = (*runtime._type)(0x10b4e20)
runtime.sliceType = (*runtime._type)(0x10b65e0)
runtime.staticuint64s = [256]uint64 [...]
runtime.lockNames = []string len: 51, cap: 51, [...]
runtime.physPageSize = 4096
runtime.physHugePageSize = 0
runtime.physHugePageShift = 0
runtime.zerobase = 0
runtime.globalAlloc = struct { runtime.mutex; runtime.persistentAlloc } {mutex: (*runtime.mutex)(0x11770a0), persistentAlloc: (*runtime.persistentAlloc)(0x11770a8)}
runtime.persistentChunks = (*runtime.notInHeap)(0x1540000)
runtime.zeroVal = [1024]uint8 [...]
runtime.emptymspan = runtime.mspan {next: *runtime.mspan nil, prev: *runtime.mspan nil, list: *runtime.mSpanList nil,...+18 more}
runtime.useCheckmark = false
runtime.finlock = runtime.mutex {lockRankStruct: runtime.lockRankStruct {}, key: 0}
runtime.fing = (*runtime.g)(0xc000082820)
runtime.finq = *runtime.finblock nil
runtime.finc = *runtime.finblock nil
runtime.finptrmask = [64]uint8 [...]
runtime.fingwait = true
runtime.fingwake = false
runtime.allfin = *runtime.finblock nil
runtime.finalizer1 = [5]uint8 [...]
runtime.fingCreate = 1
runtime.fingRunning = false
runtime.gcphase = 0
runtime.writeBarrier = struct { runtime.enabled bool; runtime.pad [3]uint8; runtime.needed bool; runtime.cgo bool; runtime.alignme uint64 } {enabled: false, pad: [3]uint8 [...], needed: false,...+2 more}
runtime.gcBlackenEnabled = 0
runtime.work = struct { runtime.full runtime.lfstack; runtime.empty runtime.lfstack; runtime.pad0 internal/cpu.CacheLinePad; runtime.wbufSpans struct { runtime.lock runtime.mutex; runtime.free runtime.mSpanList; runtime.busy runtime.mSpanList }; runtime._ uint32; runtime.bytesMarked uint64; runtime.markrootNext uint32; runtime.markrootJobs uint32; runtime.nproc uint32; runtime.tstart int64; runtime.nwait uint32; runtime.nDataRoots int; runtime.nBSSRoots int; runtime.nSpanRoots int; runtime.nStackRoots int; runtime.baseData uint32; runtime.baseBSS uint32; runtime.baseSpans uint32; runtime.baseStacks uint32; runtime.baseEnd uint32; runtime.stackRoots []*runtime.g; runtime.startSema uint32; runtime.markDoneSema uint32; runtime.bgMarkReady runtime.note; runtime.bgMarkDone uint32; runtime.mode runtime.gcMode; runtime.userForced bool; runtime.totaltime int64; runtime.initialHeapLive uint64; runtime.assistQueue struct { runtime.lock runtime.mutex; runtime.q runtime.gQueue }; runtime.sweepWaiters struct { runtime.lock runtime.mutex; runtime.list runtime.gList }; runtime.cycles uint32; runtime.stwprocs int32; runtime.maxprocs int32; runtime.tSweepTerm int64; runtime.tMark int64; runtime.tMarkTerm int64; runtime.tEnd int64; runtime.pauseNS int64; runtime.pauseStart int64; runtime.heap0 uint64; runtime.heap1 uint64; runtime.heap2 uint64; runtime.heapGoal uint64 } {full: 0, empty: 0, pad0: (*"internal/cpu.CacheLinePad")(0x1148710),...+41 more}
runtime.gcMarkDoneFlushed = 0
runtime.poolcleanup = sync.poolCleanup
runtime.oneptrmask = [1]uint8 [...]
runtime.gcController = runtime.gcControllerState {gcPercent: (*"runtime/internal/atomic.Int32")(0x1177840), _: 0, heapMinimum: 4194304,...+29 more}
runtime.scavenge = struct { runtime.lock runtime.mutex; runtime.g *runtime.g; runtime.parked bool; runtime.timer *runtime.timer; runtime.sysmonWake uint32; runtime.printControllerReset bool } {lock: (*runtime.mutex)(0x1148460), g: (*runtime.g)(0xc000002d00), parked: true,...+3 more}
runtime.sweep = runtime.sweepdata {lock: (*runtime.mutex)(0x11484a0), g: (*runtime.g)(0xc000002b60), parked: true,...+5 more}
runtime.mheap_ = runtime.mheap {lock: (*runtime.mutex)(0x1160400), pages: (*runtime.pageAlloc)(0x1160408), sweepgen: 0,...+27 more}
runtime.mSpanStateNames = []string len: 4, cap: 4, [...]
runtime.gcBitsArenas = struct { runtime.lock runtime.mutex; runtime.free *runtime.gcBitsArena; runtime.next *runtime.gcBitsArena; runtime.current *runtime.gcBitsArena; runtime.previous *runtime.gcBitsArena } {lock: (*runtime.mutex)(0x1177120), free: *runtime.gcBitsArena nil, next: (*runtime.gcBitsArena)(0x1530000),...+2 more}
runtime.maxSearchAddr = runtime.offAddr {a: 140737488355327}
runtime.levelBits = [5]uint [...]
runtime.levelShift = [5]uint [...]
runtime.levelLogPages = [5]uint [...]
runtime.proflock = runtime.mutex {lockRankStruct: runtime.lockRankStruct {}, key: 0}
runtime.mbuckets = *runtime.bucket nil
runtime.bbuckets = *runtime.bucket nil
runtime.xbuckets = *runtime.bucket nil
runtime.buckhash = *[179999]*runtime.bucket nil
runtime.bucketmem = 0
runtime.mProf = struct { runtime.cycle uint32; runtime.flushed bool } {cycle: 0, flushed: false}
runtime.blockprofilerate = 0
runtime.mutexprofilerate = 0
runtime.MemProfileRate = 0
runtime.disableMemoryProfiling = true
runtime.tracelock = runtime.mutex {lockRankStruct: runtime.lockRankStruct {}, key: 0}
runtime.minOffAddr = runtime.offAddr {a: 18446603336221196288}
runtime.maxOffAddr = runtime.offAddr {a: 140737488355327}
runtime.spanSetBlockPool = runtime.spanSetBlockAlloc {stack: 0}
runtime.memstats = runtime.mstats {alloc: 0, total_alloc: 0, sys: 0,...+33 more}
runtime.netpollInitLock = runtime.mutex {lockRankStruct: runtime.lockRankStruct {}, key: 0}
runtime.netpollInited = 0
runtime.pollcache = runtime.pollCache {lock: (*runtime.mutex)(0x1177080), first: *runtime.pollDesc nil}
runtime.netpollWaiters = 0
runtime.pdEface = interface {}(*runtime.pollDesc) 0x11411d8
runtime.pdType = (*runtime._type)(0x10b9ce0)
runtime.kq = -1
runtime.netpollBreakRd = 0
runtime.netpollBreakWr = 0
runtime.netpollWakeSig = 0
runtime.sigNoteWrite = 0
runtime.urandom_dev = []uint8 len: 13, cap: 13, [...]
runtime.failthreadcreate = []uint8 len: 40, cap: 40, [...]
runtime.sigset_all = 4294967295
runtime.shiftError = error(runtime.errorString) "negative shift amount"
runtime.divideError = error(runtime.errorString) "integer divide by zero"
runtime.overflowError = error(runtime.errorString) "integer overflow"
runtime.floatError = error(runtime.errorString) "floating point error"
runtime.memoryError = error(runtime.errorString) "invalid memory address or nil pointer dereference"
runtime.runningPanicDefers = 0
runtime.panicking = 0
runtime.paniclk = runtime.mutex {lockRankStruct: runtime.lockRankStruct {}, key: 0}
runtime.didothers = false
runtime.deadlock = runtime.mutex {lockRankStruct: runtime.lockRankStruct {}, key: 0}
runtime.asyncPreemptStack = 472
runtime.printBacklog = [512]uint8 [...]
runtime.printBacklogIndex = 0
runtime.debuglock = runtime.mutex {lockRankStruct: runtime.lockRankStruct {}, key: 0}
runtime.minhexdigits = 0
runtime.modinfo = "0w�\f�t\b\x02A��\a��\x18�path\tcommand-line-arguments\nbuild\t-compiler=gc\nb...+187 more"
runtime.m0 = runtime.m {g0: (*runtime.g)(0x1148560), morebuf: (*runtime.gobuf)(0x11488c8), divmod: 0,...+60 more}
runtime.g0 = runtime.g {stack: (*runtime.stack)(0x1148560), stackguard0: 140702053759432, stackguard1: 140702053759432,...+48 more}
runtime.mcache0 = *runtime.mcache nil
runtime.main_init_done = chan bool 0/0
runtime.mainStarted = true
runtime.runtimeInitTime = 40571062681228
runtime.initSigmask = 0
runtime.badmorestackg0Msg = "fatal: morestack on g0\n"
runtime.badmorestackgsignalMsg = "fatal: morestack on gsignal\n"
runtime.allglock = runtime.mutex {lockRankStruct: runtime.lockRankStruct {}, key: 0}
runtime.allgs = []*runtime.g len: 5, cap: 8, [...]
runtime.allglen = 5
runtime.allgptr = (**runtime.g)(0xc0000b8000)
runtime.fastrandseed = 16328898398628360364
runtime.freezing = 0
runtime.worldsema = 1
runtime.gcsema = 1
runtime.earlycgocallback = []uint8 len: 42, cap: 42, [...]
runtime.extram = 0
runtime.extraMCount = 0
runtime.extraMWaiters = 0
runtime.allocmLock = runtime.rwmutex {rLock: (*runtime.mutex)(0x11771e0), readers: 0, readerPass: 0,...+4 more}
runtime.execLock = runtime.rwmutex {rLock: (*runtime.mutex)(0x1177220), readers: 0, readerPass: 0,...+4 more}
runtime.newmHandoff = struct { runtime.lock runtime.mutex; runtime.newm runtime.muintptr; runtime.waiting bool; runtime.wake runtime.note; runtime.haveTemplateThread uint32 } {lock: (*runtime.mutex)(0x1177160), newm: 0, waiting: false,...+2 more}
runtime.pendingPreemptSignals = 0
runtime.prof = struct { runtime.signalLock uint32; runtime.hz int32 } {signalLock: 0, hz: 0}
runtime.forcegcperiod = 120000000000
runtime.starttime = 0
runtime.stealOrder = runtime.randomOrder {count: 8, coprimes: []uint32 len: 4, cap: 4, [...]}
runtime.inittrace = runtime.tracestat {active: false, id: 0, allocs: 0,...+1 more}
runtime.envs = []string len: 39, cap: 39, [...]
runtime.argslice = []string len: 1, cap: 1, [...]
runtime.traceback_cache = 4
runtime.traceback_env = 4
runtime.argc = 1
runtime.argv = (**uint8)(0x7ff7bfeff5f0)
runtime.test_z64 = 3298534883331
runtime.test_x64 = 42
runtime.debug = struct { runtime.cgocheck int32; runtime.clobberfree int32; runtime.efence int32; runtime.gccheckmark int32; runtime.gcpacertrace int32; runtime.gcshrinkstackoff int32; runtime.gcstoptheworld int32; runtime.gctrace int32; runtime.invalidptr int32; runtime.madvdontneed int32; runtime.scavtrace int32; runtime.scheddetail int32; runtime.schedtrace int32; runtime.tracebackancestors int32; runtime.asyncpreemptoff int32; runtime.harddecommit int32; runtime.malloc bool; runtime.allocfreetrace int32; runtime.inittrace int32; runtime.sbrk int32 } {cgocheck: 1, clobberfree: 0, efence: 0,...+17 more}
runtime.dbgvars = []runtime.dbgVar len: 19, cap: 19, [...]
runtime.waitReasonStrings = [27]string [...]
runtime.allm = (*runtime.m)(0xc000080000)
runtime.gomaxprocs = 8
runtime.ncpu = 8
runtime.forcegc = runtime.forcegcstate {lock: (*runtime.mutex)(0x1148300), g: (*runtime.g)(0xc000002680), idle: 1}
runtime.sched = runtime.schedt {goidgen: 32, lastpoll: 40571062474049, pollUntil: 0,...+34 more}
runtime.newprocs = 0
runtime.allpLock = runtime.mutex {lockRankStruct: runtime.lockRankStruct {}, key: 0}
runtime.allp = []*runtime.p len: 8, cap: 8, [...]
runtime.idlepMask = runtime.pMask len: 1, cap: 1, [...]
runtime.timerpMask = runtime.pMask len: 1, cap: 1, [...]
runtime.gcBgMarkWorkerPool = 0
runtime.gcBgMarkWorkerCount = 0
runtime.processorVersionInfo = 526058
runtime.isIntel = true
runtime.islibrary = false
runtime.isarchive = false
runtime.chansendpc = 16795424
runtime.chanrecvpc = 16797984
runtime.semtable = [251]struct { runtime.root runtime.semaRoot; runtime.pad [40]uint8 } [...]
runtime.sigtable = [32]runtime.sigTabT [...]
runtime.fwdSig = [32]uintptr [...]
runtime.handlingSig = [32]uint32 [...]
runtime.signalsOK = true
runtime.sigprofCallers = runtime.cgoCallers [...]
runtime.sigprofCallersUse = 0
runtime.crashing = 0
runtime.testSigtrap = nil
runtime.testSigusr1 = nil
runtime.badginsignalMsg = "fatal: bad g in signal handler\n"
runtime.sigsetAllExiting = 4294967295
runtime.sig = struct { runtime.note runtime.note; runtime.mask [1]uint32; runtime.wanted [1]uint32; runtime.ignored [1]uint32; runtime.recv [1]uint32; runtime.state uint32; runtime.delivering uint32; runtime.inuse bool } {note: (*runtime.note)(0x11771a0), mask: [1]uint32 [...], wanted: [1]uint32 [...],...+5 more}
runtime.class_to_size = [68]uint16 [...]
runtime.class_to_allocnpages = [68]uint8 [...]
runtime.class_to_divmagic = [68]uint32 [...]
runtime.size_to_class8 = [129]uint8 [...]
runtime.size_to_class128 = [249]uint8 [...]
runtime.stackpool = [4]struct { runtime.item runtime.stackpoolItem; runtime._ [40]uint8 } [...]
runtime.stackLarge = struct { runtime.lock runtime.mutex; runtime.free [35]runtime.mSpanList } {lock: (*runtime.mutex)(0x1177ba0), free: [35]runtime.mSpanList [...]}
runtime.maxstacksize = 1000000000
runtime.maxstackceiling = 2000000000
runtime.methodValueCallFrameObjs = [1]runtime.stackObjectRecord [...]
runtime.badsystemstackMsg = "fatal: systemstack called from unexpected goroutine"
runtime.intArgRegs = 9
runtime.pinnedTypemaps = []map[runtime.typeOff]*runtime._type len: 0, cap: 0, nil
runtime.firstmoduledata = runtime.moduledata {pcHeader: (*runtime.pcHeader)(0x10d3ce0), funcnametab: []uint8 len: 49488, cap: 49488, [...], cutab: []uint32 len: 1752, cap: 1752, [...],...+38 more}
runtime.modulesSlice = (*[]*runtime.moduledata)(0xc00000c000)
runtime.faketime = 0
runtime.overrideWrite = nil
runtime.trace = struct { runtime.lock runtime.mutex; runtime.lockOwner *runtime.g; runtime.enabled bool; runtime.shutdown bool; runtime.headerWritten bool; runtime.footerWritten bool; runtime.shutdownSema uint32; runtime.seqStart uint64; runtime.ticksStart int64; runtime.ticksEnd int64; runtime.timeStart int64; runtime.timeEnd int64; runtime.seqGC uint64; runtime.reading runtime.traceBufPtr; runtime.empty runtime.traceBufPtr; runtime.fullHead runtime.traceBufPtr; runtime.fullTail runtime.traceBufPtr; runtime.reader runtime.guintptr; runtime.stackTab runtime.traceStackTable; runtime.stringsLock runtime.mutex; runtime.strings map[string]uint64; runtime.stringSeq uint64; runtime.markWorkerLabels [4]uint64; runtime.bufLock runtime.mutex; runtime.buf runtime.traceBufPtr } {lock: (*runtime.mutex)(0x1150320), lockOwner: *runtime.g nil, enabled: false,...+22 more}
runtime.gStatusStrings = [10]string [...]
runtime.cgoTraceback = unsafe.Pointer(0x0)
runtime.cgoSymbolizer = unsafe.Pointer(0x0)
runtime.reflectOffs = struct { runtime.lock runtime.mutex; runtime.next int32; runtime.m map[int32]unsafe.Pointer; runtime.minv map[unsafe.Pointer]int32 } {lock: (*runtime.mutex)(0x11483e0), next: 0, m: map[int32]unsafe.Pointer nil,...+1 more}
_cgo_init = unsafe.Pointer(0x0)
_cgo_thread_start = unsafe.Pointer(0x0)
_cgo_notify_runtime_init_done = unsafe.Pointer(0x0)
_cgo_callers = unsafe.Pointer(0x0)
_cgo_yield = unsafe.Pointer(0x0)
internal/reflectlite.kindNames = []string len: 27, cap: 27, [...]
unicode.Categories = map[string]*unicode.RangeTable [...]
unicode.Cc = (*unicode.RangeTable)(0x1143440)
unicode.Cf = (*unicode.RangeTable)(0x11449c0)
unicode.Co = (*unicode.RangeTable)(0x1144e80)
unicode.Cs = (*unicode.RangeTable)(0x1141700)
unicode.Nd = (*unicode.RangeTable)(0x1143940)
unicode.L = (*unicode.RangeTable)(0x1141980)
unicode.Lm = (*unicode.RangeTable)(0x1141fc0)
unicode.Lo = (*unicode.RangeTable)(0x11422c0)
unicode.Ll = (*unicode.RangeTable)(0x1141c80)
unicode.M = (*unicode.RangeTable)(0x1142b00)
unicode.Mc = (*unicode.RangeTable)(0x1142e00)
unicode.Me = (*unicode.RangeTable)(0x1143100)
unicode.Mn = (*unicode.RangeTable)(0x1143300)
unicode.Nl = (*unicode.RangeTable)(0x1143cc0)
unicode.No = (*unicode.RangeTable)(0x1144000)
unicode.N = (*unicode.RangeTable)(0x1143640)
unicode.C = (*unicode.RangeTable)(0x1141500)
unicode.Pc = (*unicode.RangeTable)(0x1144680)
unicode.Pd = (*unicode.RangeTable)(0x11448c0)
unicode.Pe = (*unicode.RangeTable)(0x1144bc0)
unicode.Pf = (*unicode.RangeTable)(0x1144c00)
unicode.Pi = (*unicode.RangeTable)(0x1144c40)
unicode.Po = (*unicode.RangeTable)(0x1144c80)
unicode.Ps = (*unicode.RangeTable)(0x1144cc0)
unicode.P = (*unicode.RangeTable)(0x1144380)
unicode.Sc = (*unicode.RangeTable)(0x1144d40)
unicode.Sk = (*unicode.RangeTable)(0x1144d80)
unicode.Sm = (*unicode.RangeTable)(0x1144dc0)
unicode.So = (*unicode.RangeTable)(0x1144e00)
unicode.Z = (*unicode.RangeTable)(0x1144e40)
unicode.S = (*unicode.RangeTable)(0x1144d00)
unicode.Lt = (*unicode.RangeTable)(0x11425c0)
unicode.Lu = (*unicode.RangeTable)(0x1142800)
unicode.Zl = (*unicode.RangeTable)(0x1144ec0)
unicode.Zp = (*unicode.RangeTable)(0x1144f00)
unicode.Zs = (*unicode.RangeTable)(0x1144f40)
unicode.Scripts = map[string]*unicode.RangeTable [...]
unicode.Adlam = (*unicode.RangeTable)(0x1144f80)
unicode.Ahom = (*unicode.RangeTable)(0x1141540)
unicode.Anatolian_Hieroglyphs = (*unicode.RangeTable)(0x1141580)
unicode.Arabic = (*unicode.RangeTable)(0x11415c0)
unicode.Armenian = (*unicode.RangeTable)(0x1141600)
unicode.Avestan = (*unicode.RangeTable)(0x1141640)
unicode.Balinese = (*unicode.RangeTable)(0x1141680)
unicode.Bamum = (*unicode.RangeTable)(0x11416c0)
unicode.Bassa_Vah = (*unicode.RangeTable)(0x1141740)
unicode.Batak = (*unicode.RangeTable)(0x1141780)
unicode.Bengali = (*unicode.RangeTable)(0x11417c0)
unicode.Bhaiksuki = (*unicode.RangeTable)(0x1141800)
unicode.Bopomofo = (*unicode.RangeTable)(0x1141840)
unicode.Brahmi = (*unicode.RangeTable)(0x1141880)
unicode.Braille = (*unicode.RangeTable)(0x11418c0)
unicode.Buginese = (*unicode.RangeTable)(0x1141900)
unicode.Buhid = (*unicode.RangeTable)(0x1141940)
unicode.Canadian_Aboriginal = (*unicode.RangeTable)(0x11419c0)
unicode.Carian = (*unicode.RangeTable)(0x1141a00)
unicode.Caucasian_Albanian = (*unicode.RangeTable)(0x1141a40)
unicode.Chakma = (*unicode.RangeTable)(0x1141a80)
unicode.Cham = (*unicode.RangeTable)(0x1141ac0)
unicode.Cherokee = (*unicode.RangeTable)(0x1141b00)
unicode.Chorasmian = (*unicode.RangeTable)(0x1141b40)
unicode.Common = (*unicode.RangeTable)(0x1141b80)
unicode.Coptic = (*unicode.RangeTable)(0x1141bc0)
unicode.Cuneiform = (*unicode.RangeTable)(0x1141c00)
unicode.Cypriot = (*unicode.RangeTable)(0x1141c40)
unicode.Cyrillic = (*unicode.RangeTable)(0x1141cc0)
unicode.Deseret = (*unicode.RangeTable)(0x1141d00)
unicode.Devanagari = (*unicode.RangeTable)(0x1141d40)
unicode.Dives_Akuru = (*unicode.RangeTable)(0x1141d80)
unicode.Dogra = (*unicode.RangeTable)(0x1141dc0)
unicode.Duployan = (*unicode.RangeTable)(0x1141e00)
unicode.Egyptian_Hieroglyphs = (*unicode.RangeTable)(0x1141e40)
unicode.Elbasan = (*unicode.RangeTable)(0x1141e80)
unicode.Elymaic = (*unicode.RangeTable)(0x1141ec0)
unicode.Ethiopic = (*unicode.RangeTable)(0x1141f00)
unicode.Georgian = (*unicode.RangeTable)(0x1141f40)
unicode.Glagolitic = (*unicode.RangeTable)(0x1141f80)
unicode.Gothic = (*unicode.RangeTable)(0x1142000)
unicode.Grantha = (*unicode.RangeTable)(0x1142040)
unicode.Greek = (*unicode.RangeTable)(0x1142080)
unicode.Gujarati = (*unicode.RangeTable)(0x11420c0)
unicode.Gunjala_Gondi = (*unicode.RangeTable)(0x1142100)
unicode.Gurmukhi = (*unicode.RangeTable)(0x1142140)
unicode.Han = (*unicode.RangeTable)(0x1142180)
unicode.Hangul = (*unicode.RangeTable)(0x11421c0)
unicode.Hanifi_Rohingya = (*unicode.RangeTable)(0x1142200)
unicode.Hanunoo = (*unicode.RangeTable)(0x1142240)
unicode.Hatran = (*unicode.RangeTable)(0x1142280)
unicode.Hebrew = (*unicode.RangeTable)(0x1142300)
unicode.Hiragana = (*unicode.RangeTable)(0x1142340)
unicode.Imperial_Aramaic = (*unicode.RangeTable)(0x1142380)
unicode.Inherited = (*unicode.RangeTable)(0x11423c0)
unicode.Inscriptional_Pahlavi = (*unicode.RangeTable)(0x1142400)
unicode.Inscriptional_Parthian = (*unicode.RangeTable)(0x1142440)
unicode.Javanese = (*unicode.RangeTable)(0x1142480)
unicode.Kaithi = (*unicode.RangeTable)(0x11424c0)
unicode.Kannada = (*unicode.RangeTable)(0x1142500)
unicode.Katakana = (*unicode.RangeTable)(0x1142540)
unicode.Kayah_Li = (*unicode.RangeTable)(0x1142580)
unicode.Kharoshthi = (*unicode.RangeTable)(0x1142600)
unicode.Khitan_Small_Script = (*unicode.RangeTable)(0x1142640)
unicode.Khmer = (*unicode.RangeTable)(0x1142680)
unicode.Khojki = (*unicode.RangeTable)(0x11426c0)
unicode.Khudawadi = (*unicode.RangeTable)(0x1142700)
unicode.Lao = (*unicode.RangeTable)(0x1142740)
unicode.Latin = (*unicode.RangeTable)(0x1142780)
unicode.Lepcha = (*unicode.RangeTable)(0x11427c0)
unicode.Limbu = (*unicode.RangeTable)(0x1142840)
unicode.Linear_A = (*unicode.RangeTable)(0x1142880)
unicode.Linear_B = (*unicode.RangeTable)(0x11428c0)
unicode.Lisu = (*unicode.RangeTable)(0x1142900)
unicode.Lycian = (*unicode.RangeTable)(0x1142940)
unicode.Lydian = (*unicode.RangeTable)(0x1142980)
unicode.Mahajani = (*unicode.RangeTable)(0x11429c0)
unicode.Makasar = (*unicode.RangeTable)(0x1142a00)
unicode.Malayalam = (*unicode.RangeTable)(0x1142a40)
unicode.Mandaic = (*unicode.RangeTable)(0x1142a80)
unicode.Manichaean = (*unicode.RangeTable)(0x1142ac0)
unicode.Marchen = (*unicode.RangeTable)(0x1142b40)
unicode.Masaram_Gondi = (*unicode.RangeTable)(0x1142b80)
unicode.Medefaidrin = (*unicode.RangeTable)(0x1142bc0)
unicode.Meetei_Mayek = (*unicode.RangeTable)(0x1142c00)
unicode.Mende_Kikakui = (*unicode.RangeTable)(0x1142c40)
unicode.Meroitic_Cursive = (*unicode.RangeTable)(0x1142c80)
unicode.Meroitic_Hieroglyphs = (*unicode.RangeTable)(0x1142cc0)
unicode.Miao = (*unicode.RangeTable)(0x1142d00)
unicode.Modi = (*unicode.RangeTable)(0x1142d40)
unicode.Mongolian = (*unicode.RangeTable)(0x1142d80)
unicode.Mro = (*unicode.RangeTable)(0x1142dc0)
unicode.Multani = (*unicode.RangeTable)(0x1142e40)
unicode.Myanmar = (*unicode.RangeTable)(0x1142e80)
unicode.Nabataean = (*unicode.RangeTable)(0x1142ec0)
unicode.Nandinagari = (*unicode.RangeTable)(0x1142f00)
unicode.New_Tai_Lue = (*unicode.RangeTable)(0x1142f40)
unicode.Newa = (*unicode.RangeTable)(0x1142f80)
unicode.Nko = (*unicode.RangeTable)(0x1142fc0)
unicode.Nushu = (*unicode.RangeTable)(0x1143000)
unicode.Nyiakeng_Puachue_Hmong = (*unicode.RangeTable)(0x1143040)
unicode.Ogham = (*unicode.RangeTable)(0x1143080)
unicode.Ol_Chiki = (*unicode.RangeTable)(0x11430c0)
unicode.Old_Hungarian = (*unicode.RangeTable)(0x1143140)
unicode.Old_Italic = (*unicode.RangeTable)(0x1143180)
unicode.Old_North_Arabian = (*unicode.RangeTable)(0x11431c0)
unicode.Old_Permic = (*unicode.RangeTable)(0x1143200)
unicode.Old_Persian = (*unicode.RangeTable)(0x1143240)
unicode.Old_Sogdian = (*unicode.RangeTable)(0x1143280)
unicode.Old_South_Arabian = (*unicode.RangeTable)(0x11432c0)
unicode.Old_Turkic = (*unicode.RangeTable)(0x1143340)
unicode.Oriya = (*unicode.RangeTable)(0x1143380)
unicode.Osage = (*unicode.RangeTable)(0x11433c0)
unicode.Osmanya = (*unicode.RangeTable)(0x1143400)
unicode.Pahawh_Hmong = (*unicode.RangeTable)(0x1143480)
unicode.Palmyrene = (*unicode.RangeTable)(0x11434c0)
unicode.Pau_Cin_Hau = (*unicode.RangeTable)(0x1143500)
unicode.Phags_Pa = (*unicode.RangeTable)(0x1143540)
unicode.Phoenician = (*unicode.RangeTable)(0x1143580)
unicode.Psalter_Pahlavi = (*unicode.RangeTable)(0x11435c0)
unicode.Rejang = (*unicode.RangeTable)(0x1143600)
unicode.Runic = (*unicode.RangeTable)(0x1143680)
unicode.Samaritan = (*unicode.RangeTable)(0x11436c0)
unicode.Saurashtra = (*unicode.RangeTable)(0x1143700)
unicode.Sharada = (*unicode.RangeTable)(0x1143740)
unicode.Shavian = (*unicode.RangeTable)(0x1143780)
unicode.Siddham = (*unicode.RangeTable)(0x11437c0)
unicode.SignWriting = (*unicode.RangeTable)(0x1143800)
unicode.Sinhala = (*unicode.RangeTable)(0x1143840)
unicode.Sogdian = (*unicode.RangeTable)(0x1143880)
unicode.Sora_Sompeng = (*unicode.RangeTable)(0x11438c0)
unicode.Soyombo = (*unicode.RangeTable)(0x1143900)
unicode.Sundanese = (*unicode.RangeTable)(0x1143980)
unicode.Syloti_Nagri = (*unicode.RangeTable)(0x11439c0)
unicode.Syriac = (*unicode.RangeTable)(0x1143a00)
unicode.Tagalog = (*unicode.RangeTable)(0x1143a40)
unicode.Tagbanwa = (*unicode.RangeTable)(0x1143a80)
unicode.Tai_Le = (*unicode.RangeTable)(0x1143ac0)
unicode.Tai_Tham = (*unicode.RangeTable)(0x1143b00)
unicode.Tai_Viet = (*unicode.RangeTable)(0x1143b40)
unicode.Takri = (*unicode.RangeTable)(0x1143b80)
unicode.Tamil = (*unicode.RangeTable)(0x1143bc0)
unicode.Tangut = (*unicode.RangeTable)(0x1143c00)
unicode.Telugu = (*unicode.RangeTable)(0x1143c40)
unicode.Thaana = (*unicode.RangeTable)(0x1143c80)
unicode.Thai = (*unicode.RangeTable)(0x1143d00)
unicode.Tibetan = (*unicode.RangeTable)(0x1143d40)
unicode.Tifinagh = (*unicode.RangeTable)(0x1143d80)
unicode.Tirhuta = (*unicode.RangeTable)(0x1143dc0)
unicode.Ugaritic = (*unicode.RangeTable)(0x1143e00)
unicode.Vai = (*unicode.RangeTable)(0x1143e40)
unicode.Wancho = (*unicode.RangeTable)(0x1143e80)
unicode.Warang_Citi = (*unicode.RangeTable)(0x1143ec0)
unicode.Yezidi = (*unicode.RangeTable)(0x1143f00)
unicode.Yi = (*unicode.RangeTable)(0x1143f40)
unicode.Zanabazar_Square = (*unicode.RangeTable)(0x1143f80)
unicode.Properties = map[string]*unicode.RangeTable [...]
unicode.ASCII_Hex_Digit = (*unicode.RangeTable)(0x1143fc0)
unicode.Bidi_Control = (*unicode.RangeTable)(0x1144040)
unicode.Dash = (*unicode.RangeTable)(0x1144080)
unicode.Deprecated = (*unicode.RangeTable)(0x11440c0)
unicode.Diacritic = (*unicode.RangeTable)(0x1144100)
unicode.Extender = (*unicode.RangeTable)(0x1144140)
unicode.Hex_Digit = (*unicode.RangeTable)(0x1144180)
unicode.Hyphen = (*unicode.RangeTable)(0x11441c0)
unicode.IDS_Binary_Operator = (*unicode.RangeTable)(0x1144200)
unicode.IDS_Trinary_Operator = (*unicode.RangeTable)(0x1144240)
unicode.Ideographic = (*unicode.RangeTable)(0x1144280)
unicode.Join_Control = (*unicode.RangeTable)(0x11442c0)
unicode.Logical_Order_Exception = (*unicode.RangeTable)(0x1144300)
unicode.Noncharacter_Code_Point = (*unicode.RangeTable)(0x1144340)
unicode.Other_Alphabetic = (*unicode.RangeTable)(0x11443c0)
unicode.Other_Default_Ignorable_Code_Point = (*unicode.RangeTable)(0x1144400)
unicode.Other_Grapheme_Extend = (*unicode.RangeTable)(0x1144440)
unicode.Other_ID_Continue = (*unicode.RangeTable)(0x1144480)
unicode.Other_ID_Start = (*unicode.RangeTable)(0x11444c0)
unicode.Other_Lowercase = (*unicode.RangeTable)(0x1144500)
unicode.Other_Math = (*unicode.RangeTable)(0x1144540)
unicode.Other_Uppercase = (*unicode.RangeTable)(0x1144580)
unicode.Pattern_Syntax = (*unicode.RangeTable)(0x11445c0)
unicode.Pattern_White_Space = (*unicode.RangeTable)(0x1144600)
unicode.Prepended_Concatenation_Mark = (*unicode.RangeTable)(0x1144640)
unicode.Quotation_Mark = (*unicode.RangeTable)(0x11446c0)
unicode.Radical = (*unicode.RangeTable)(0x1144700)
unicode.Regional_Indicator = (*unicode.RangeTable)(0x1144740)
unicode.Sentence_Terminal = (*unicode.RangeTable)(0x1144780)
unicode.Soft_Dotted = (*unicode.RangeTable)(0x11447c0)
unicode.Terminal_Punctuation = (*unicode.RangeTable)(0x1144800)
unicode.Unified_Ideograph = (*unicode.RangeTable)(0x1144840)
unicode.Variation_Selector = (*unicode.RangeTable)(0x1144880)
unicode.White_Space = (*unicode.RangeTable)(0x1144900)
unicode.FoldCategory = map[string]*unicode.RangeTable [...]
unicode.foldL = (*unicode.RangeTable)(0x1144940)
unicode.foldLl = (*unicode.RangeTable)(0x1144980)
unicode.foldLt = (*unicode.RangeTable)(0x1144a00)
unicode.foldLu = (*unicode.RangeTable)(0x1144a40)
unicode.foldM = (*unicode.RangeTable)(0x1144a80)
unicode.foldMn = (*unicode.RangeTable)(0x1144ac0)
unicode.FoldScript = map[string]*unicode.RangeTable [...]
unicode.foldCommon = (*unicode.RangeTable)(0x1144b00)
unicode.foldGreek = (*unicode.RangeTable)(0x1144b40)
unicode.foldInherited = (*unicode.RangeTable)(0x1144b80)
errors.errorType = internal/reflectlite.Type(*internal/reflectlite.rtype) 0x1147ef8
unicode/utf8.first = [256]uint8 [...]
unicode/utf8.acceptRanges = [16]unicode/utf8.acceptRange [...]
strconv.optimize = true
strconv.ErrRange = error(*errors.errorString) 0x1148198
strconv.ErrSyntax = error(*errors.errorString) 0x11481a8
strconv.leftcheats = []strconv.leftCheat len: 61, cap: 61, [...]
strconv.detailedPowersOfTen = [696][2]uint64 [...]
strconv.float32info = strconv.floatInfo {mantbits: 23, expbits: 8, bias: -127}
strconv.float64info = strconv.floatInfo {mantbits: 52, expbits: 11, bias: -1023}
strconv.uint64pow10 = [20]uint64 [...]
strconv.isPrint16 = []uint16 len: 434, cap: 434, [...]
strconv.isNotPrint16 = []uint16 len: 132, cap: 132, [...]
strconv.isPrint32 = []uint32 len: 468, cap: 468, [...]
strconv.isNotPrint32 = []uint16 len: 95, cap: 95, [...]
strconv.isGraphic = []uint16 len: 16, cap: 16, [...]
sync/atomic.firstStoreInProgress = 0
sync.expunged = unsafe.Pointer(0xc000096020)
sync.allPoolsMu = sync.Mutex {state: 0, sema: 0}
sync.allPools = []*sync.Pool len: 0, cap: 0, nil
sync.oldPools = []*sync.Pool len: 0, cap: 0, nil
(dlv) var main
(dlv) s
> main.CanEnd() ./main.go:37 (hits goroutine(1):2 total:2) (PC: 0x10ad333)
	end: 5
	startIdx: -1
    32:	                break
    33:	            }            
    34:	        }
    35:	        jmps++
    36:	    }
=>  37:	        return startIdx == end -1 
    38:	}
    39:	
    40:	func getMinOfGreater (arr []int, startIdx , val int) int {
    41:	    min := math.MaxInt
    42:	    next:=-1
(dlv) bp
Breakpoint runtime-fatal-throw (enabled) at 0x1033f60 for runtime.throw() /usr/local/go/src/runtime/panic.go:982 (0)
Breakpoint unrecovered-panic (enabled) at 0x1034320 for runtime.fatalpanic() /usr/local/go/src/runtime/panic.go:1065 (0)
	print runtime.curg._panic.arg
Breakpoint 1 (enabled) at 0x10ad333 for main.CanEnd() ./main.go:37 (2)
	print end
	print startIdx
Breakpoint 2 (enabled) at 0x10ad473 for main.getMinOfGreater() ./main.go:45 (2)
	print min
	print next
Breakpoint 3 (enabled) at 0x10ad5c9 for main.getMaxofSmaller() ./main.go:58 (0)
	print max
	print next
(dlv) s
> main.oddEvenJumps() ./main.go:11 (PC: 0x10ad192)
Values returned:
	~r0: false

     6:	)
     7:	
     8:	func oddEvenJumps(arr []int) int {
     9:	    jmps := 0    
    10:	    for i,val := range arr {
=>  11:	        if CanEnd(arr,i+1, val) {
    12:	            jmps++
    13:	        }
    14:	    }
    15:	    
    16:	    return jmps 
(dlv) s
> main.oddEvenJumps() ./main.go:10 (PC: 0x10ad1af)
     5:		"fmt"
     6:	)
     7:	
     8:	func oddEvenJumps(arr []int) int {
     9:	    jmps := 0    
=>  10:	    for i,val := range arr {
    11:	        if CanEnd(arr,i+1, val) {
    12:	            jmps++
    13:	        }
    14:	    }
    15:	    
(dlv) s
> main.oddEvenJumps() ./main.go:11 (PC: 0x10ad16c)
     6:	)
     7:	
     8:	func oddEvenJumps(arr []int) int {
     9:	    jmps := 0    
    10:	    for i,val := range arr {
=>  11:	        if CanEnd(arr,i+1, val) {
    12:	            jmps++
    13:	        }
    14:	    }
    15:	    
    16:	    return jmps 
(dlv) bp
Breakpoint runtime-fatal-throw (enabled) at 0x1033f60 for runtime.throw() /usr/local/go/src/runtime/panic.go:982 (0)
Breakpoint unrecovered-panic (enabled) at 0x1034320 for runtime.fatalpanic() /usr/local/go/src/runtime/panic.go:1065 (0)
	print runtime.curg._panic.arg
Breakpoint 1 (enabled) at 0x10ad333 for main.CanEnd() ./main.go:37 (2)
	print end
	print startIdx
Breakpoint 2 (enabled) at 0x10ad473 for main.getMinOfGreater() ./main.go:45 (2)
	print min
	print next
Breakpoint 3 (enabled) at 0x10ad5c9 for main.getMaxofSmaller() ./main.go:58 (0)
	print max
	print next
(dlv) on 1 print jmps
(dlv) bp
Breakpoint runtime-fatal-throw (enabled) at 0x1033f60 for runtime.throw() /usr/local/go/src/runtime/panic.go:982 (0)
Breakpoint unrecovered-panic (enabled) at 0x1034320 for runtime.fatalpanic() /usr/local/go/src/runtime/panic.go:1065 (0)
	print runtime.curg._panic.arg
Breakpoint 1 (enabled) at 0x10ad333 for main.CanEnd() ./main.go:37 (2)
	print end
	print startIdx
	print jmps
Breakpoint 2 (enabled) at 0x10ad473 for main.getMinOfGreater() ./main.go:45 (2)
	print min
	print next
Breakpoint 3 (enabled) at 0x10ad5c9 for main.getMaxofSmaller() ./main.go:58 (0)
	print max
	print next
(dlv) n
> main.getMinOfGreater() ./main.go:45 (hits goroutine(1):3 total:3) (PC: 0x10ad473)
	min: 9223372036854775807
	next: -1
    40:	func getMinOfGreater (arr []int, startIdx , val int) int {
    41:	    min := math.MaxInt
    42:	    next:=-1
    43:	    for i:=startIdx;i < len(arr);i++ {
    44:	        if arr[i]>val && arr[i]<min{
=>  45:	            min = arr[i]
    46:	            next = i
    47:	        }
    48:	    }
    49:	    return next
    50:	}
(dlv) n
> main.getMinOfGreater() ./main.go:46 (PC: 0x10ad495)
    41:	    min := math.MaxInt
    42:	    next:=-1
    43:	    for i:=startIdx;i < len(arr);i++ {
    44:	        if arr[i]>val && arr[i]<min{
    45:	            min = arr[i]
=>  46:	            next = i
    47:	        }
    48:	    }
    49:	    return next
    50:	}
    51:	
(dlv) n
> main.getMinOfGreater() ./main.go:43 (PC: 0x10ad3f4)
    38:	}
    39:	
    40:	func getMinOfGreater (arr []int, startIdx , val int) int {
    41:	    min := math.MaxInt
    42:	    next:=-1
=>  43:	    for i:=startIdx;i < len(arr);i++ {
    44:	        if arr[i]>val && arr[i]<min{
    45:	            min = arr[i]
    46:	            next = i
    47:	        }
    48:	    }
(dlv) n
> main.getMinOfGreater() ./main.go:49 (PC: 0x10ad4b8)
    44:	        if arr[i]>val && arr[i]<min{
    45:	            min = arr[i]
    46:	            next = i
    47:	        }
    48:	    }
=>  49:	    return next
    50:	}
    51:	
    52:	func getMaxofSmaller (arr []int, startIdx , val int) int {
    53:	    max := 0
    54:	        next:=-1
(dlv) n
> main.CanEnd() ./main.go:25 (PC: 0x10ad2bd)
Values returned:
	~r0: 4

    20:	    jmps := 1
    21:	    end:=len(arr)
    22:	    
    23:	    for startIdx<end{
    24:	        if jmps % 2 == 1 {
=>  25:	            startIdx = getMinOfGreater (arr , startIdx , arr[startIdx])
    26:	            if startIdx == -1{
    27:	                break
    28:	            }
    29:	        }else{
    30:	            startIdx = getMaxofSmaller (arr , startIdx , arr[startIdx])
(dlv) n
> main.CanEnd() ./main.go:26 (PC: 0x10ad2c2)
    21:	    end:=len(arr)
    22:	    
    23:	    for startIdx<end{
    24:	        if jmps % 2 == 1 {
    25:	            startIdx = getMinOfGreater (arr , startIdx , arr[startIdx])
=>  26:	            if startIdx == -1{
    27:	                break
    28:	            }
    29:	        }else{
    30:	            startIdx = getMaxofSmaller (arr , startIdx , arr[startIdx])
    31:	            if startIdx == -1{
(dlv) n
> main.CanEnd() ./main.go:35 (PC: 0x10ad2cc)
    30:	            startIdx = getMaxofSmaller (arr , startIdx , arr[startIdx])
    31:	            if startIdx == -1{
    32:	                break
    33:	            }            
    34:	        }
=>  35:	        jmps++
    36:	    }
    37:	        return startIdx == end -1 
    38:	}
    39:	
    40:	func getMinOfGreater (arr []int, startIdx , val int) int {
(dlv) n
> main.CanEnd() ./main.go:23 (PC: 0x10ad24e)
    18:	
    19:	func CanEnd(arr []int,startIdx, val int) bool {
    20:	    jmps := 1
    21:	    end:=len(arr)
    22:	    
=>  23:	    for startIdx<end{
    24:	        if jmps % 2 == 1 {
    25:	            startIdx = getMinOfGreater (arr , startIdx , arr[startIdx])
    26:	            if startIdx == -1{
    27:	                break
    28:	            }
(dlv) n
> main.CanEnd() ./main.go:24 (PC: 0x10ad25f)
    19:	func CanEnd(arr []int,startIdx, val int) bool {
    20:	    jmps := 1
    21:	    end:=len(arr)
    22:	    
    23:	    for startIdx<end{
=>  24:	        if jmps % 2 == 1 {
    25:	            startIdx = getMinOfGreater (arr , startIdx , arr[startIdx])
    26:	            if startIdx == -1{
    27:	                break
    28:	            }
    29:	        }else{
(dlv) n
> main.CanEnd() ./main.go:30 (PC: 0x10ad2ce)
    25:	            startIdx = getMinOfGreater (arr , startIdx , arr[startIdx])
    26:	            if startIdx == -1{
    27:	                break
    28:	            }
    29:	        }else{
=>  30:	            startIdx = getMaxofSmaller (arr , startIdx , arr[startIdx])
    31:	            if startIdx == -1{
    32:	                break
    33:	            }            
    34:	        }
    35:	        jmps++
(dlv) n
> main.CanEnd() ./main.go:31 (PC: 0x10ad311)
    26:	            if startIdx == -1{
    27:	                break
    28:	            }
    29:	        }else{
    30:	            startIdx = getMaxofSmaller (arr , startIdx , arr[startIdx])
=>  31:	            if startIdx == -1{
    32:	                break
    33:	            }            
    34:	        }
    35:	        jmps++
    36:	    }
(dlv) n
> main.CanEnd() ./main.go:32 (PC: 0x10ad319)
    27:	                break
    28:	            }
    29:	        }else{
    30:	            startIdx = getMaxofSmaller (arr , startIdx , arr[startIdx])
    31:	            if startIdx == -1{
=>  32:	                break
    33:	            }            
    34:	        }
    35:	        jmps++
    36:	    }
    37:	        return startIdx == end -1 
(dlv) n
> main.CanEnd() ./main.go:37 (hits goroutine(1):3 total:3) (PC: 0x10ad333)
	end: 5
	startIdx: -1
	jmps: 2
    32:	                break
    33:	            }            
    34:	        }
    35:	        jmps++
    36:	    }
=>  37:	        return startIdx == end -1 
    38:	}
    39:	
    40:	func getMinOfGreater (arr []int, startIdx , val int) int {
    41:	    min := math.MaxInt
    42:	    next:=-1
(dlv) n
> main.oddEvenJumps() ./main.go:11 (PC: 0x10ad192)
Values returned:
	~r0: false

     6:	)
     7:	
     8:	func oddEvenJumps(arr []int) int {
     9:	    jmps := 0    
    10:	    for i,val := range arr {
=>  11:	        if CanEnd(arr,i+1, val) {
    12:	            jmps++
    13:	        }
    14:	    }
    15:	    
    16:	    return jmps 
(dlv) break main.go:35
Breakpoint 4 set at 0x10ad2cc for main.CanEnd() ./main.go:35
(dlv) on 4 print startIdx
(dlv) on 4 print jmps
(dlv) n
> main.oddEvenJumps() ./main.go:10 (PC: 0x10ad1af)
     5:		"fmt"
     6:	)
     7:	
     8:	func oddEvenJumps(arr []int) int {
     9:	    jmps := 0    
=>  10:	    for i,val := range arr {
    11:	        if CanEnd(arr,i+1, val) {
    12:	            jmps++
    13:	        }
    14:	    }
    15:	    
(dlv) n
> main.oddEvenJumps() ./main.go:11 (PC: 0x10ad16c)
     6:	)
     7:	
     8:	func oddEvenJumps(arr []int) int {
     9:	    jmps := 0    
    10:	    for i,val := range arr {
=>  11:	        if CanEnd(arr,i+1, val) {
    12:	            jmps++
    13:	        }
    14:	    }
    15:	    
    16:	    return jmps 
(dlv) n
> main.CanEnd() ./main.go:37 (hits goroutine(1):4 total:4) (PC: 0x10ad333)
	end: 5
	startIdx: -1
	jmps: 1
    32:	                break
    33:	            }            
    34:	        }
    35:	        jmps++
    36:	    }
=>  37:	        return startIdx == end -1 
    38:	}
    39:	
    40:	func getMinOfGreater (arr []int, startIdx , val int) int {
    41:	    min := math.MaxInt
    42:	    next:=-1
(dlv) n
> main.oddEvenJumps() ./main.go:11 (PC: 0x10ad192)
Values returned:
	~r0: false

     6:	)
     7:	
     8:	func oddEvenJumps(arr []int) int {
     9:	    jmps := 0    
    10:	    for i,val := range arr {
=>  11:	        if CanEnd(arr,i+1, val) {
    12:	            jmps++
    13:	        }
    14:	    }
    15:	    
    16:	    return jmps 
(dlv) n
> main.oddEvenJumps() ./main.go:10 (PC: 0x10ad1af)
     5:		"fmt"
     6:	)
     7:	
     8:	func oddEvenJumps(arr []int) int {
     9:	    jmps := 0    
=>  10:	    for i,val := range arr {
    11:	        if CanEnd(arr,i+1, val) {
    12:	            jmps++
    13:	        }
    14:	    }
    15:	    
(dlv) n
> main.oddEvenJumps() ./main.go:11 (PC: 0x10ad16c)
     6:	)
     7:	
     8:	func oddEvenJumps(arr []int) int {
     9:	    jmps := 0    
    10:	    for i,val := range arr {
=>  11:	        if CanEnd(arr,i+1, val) {
    12:	            jmps++
    13:	        }
    14:	    }
    15:	    
    16:	    return jmps 
(dlv) n
> main.CanEnd() ./main.go:37 (hits goroutine(1):5 total:5) (PC: 0x10ad333)
	end: 5
	startIdx: 5
	jmps: 1
    32:	                break
    33:	            }            
    34:	        }
    35:	        jmps++
    36:	    }
=>  37:	        return startIdx == end -1 
    38:	}
    39:	
    40:	func getMinOfGreater (arr []int, startIdx , val int) int {
    41:	    min := math.MaxInt
    42:	    next:=-1
(dlv) r
Process restarted with PID 47066
(dlv) c
> main.getMinOfGreater() ./main.go:45 (hits goroutine(1):1 total:1) (PC: 0x10ad473)
	min: 9223372036854775807
	next: -1
Warning: listing may not match stale executable
    40:	func getMinOfGreater (arr []int, startIdx , val int) int {
    41:	    min := math.MaxInt
    42:	    next:=-1
    43:	    for i:=startIdx;i < len(arr);i++ {
    44:	        if arr[i]>val && arr[i]<min{
=>  45:	            min = arr[i]
    46:	            next = i
    47:	        }
    48:	    }
    49:	    return next
    50:	}
(dlv) bp
Breakpoint runtime-fatal-throw (enabled) at 0x1033f60 for runtime.throw() /usr/local/go/src/runtime/panic.go:982 (0)
Breakpoint unrecovered-panic (enabled) at 0x1034320 for runtime.fatalpanic() /usr/local/go/src/runtime/panic.go:1065 (0)
	print runtime.curg._panic.arg
Breakpoint 1 (enabled) at 0x10ad333 for main.CanEnd() ./main.go:37 (0)
	print end
	print startIdx
	print jmps
Breakpoint 2 (enabled) at 0x10ad473 for main.getMinOfGreater() ./main.go:45 (1)
	print min
	print next
Breakpoint 3 (enabled) at 0x10ad5c9 for main.getMaxofSmaller() ./main.go:58 (0)
	print max
	print next
Breakpoint 4 (enabled) at 0x10ad2cc for main.CanEnd() ./main.go:35 (0)
	print startIdx
	print jmps
(dlv) c
> main.CanEnd() ./main.go:35 (hits goroutine(1):1 total:1) (PC: 0x10ad2cc)
	startIdx: 3
	jmps: 1
Warning: listing may not match stale executable
    30:	            startIdx = getMaxofSmaller (arr , startIdx , arr[startIdx])
    31:	            if startIdx == -1{
    32:	                break
    33:	            }            
    34:	        }
=>  35:	        jmps++
    36:	    }
    37:	        return startIdx == end
    38:	}
    39:	
    40:	func getMinOfGreater (arr []int, startIdx , val int) int {
(dlv) c
> main.CanEnd() ./main.go:37 (hits goroutine(1):1 total:1) (PC: 0x10ad333)
	end: 5
	startIdx: -1
	jmps: 2
Warning: listing may not match stale executable
    32:	                break
    33:	            }            
    34:	        }
    35:	        jmps++
    36:	    }
=>  37:	        return startIdx == end
    38:	}
    39:	
    40:	func getMinOfGreater (arr []int, startIdx , val int) int {
    41:	    min := math.MaxInt
    42:	    next:=-1
(dlv) c
> main.getMinOfGreater() ./main.go:45 (hits goroutine(1):2 total:2) (PC: 0x10ad473)
	min: 9223372036854775807
	next: -1
Warning: listing may not match stale executable
    40:	func getMinOfGreater (arr []int, startIdx , val int) int {
    41:	    min := math.MaxInt
    42:	    next:=-1
    43:	    for i:=startIdx;i < len(arr);i++ {
    44:	        if arr[i]>val && arr[i]<min{
=>  45:	            min = arr[i]
    46:	            next = i
    47:	        }
    48:	    }
    49:	    return next
    50:	}
(dlv) c
> main.CanEnd() ./main.go:35 (hits goroutine(1):2 total:2) (PC: 0x10ad2cc)
	startIdx: 3
	jmps: 1
Warning: listing may not match stale executable
    30:	            startIdx = getMaxofSmaller (arr , startIdx , arr[startIdx])
    31:	            if startIdx == -1{
    32:	                break
    33:	            }            
    34:	        }
=>  35:	        jmps++
    36:	    }
    37:	        return startIdx == end
    38:	}
    39:	
    40:	func getMinOfGreater (arr []int, startIdx , val int) int {
(dlv) c
> main.CanEnd() ./main.go:37 (hits goroutine(1):2 total:2) (PC: 0x10ad333)
	end: 5
	startIdx: -1
	jmps: 2
Warning: listing may not match stale executable
    32:	                break
    33:	            }            
    34:	        }
    35:	        jmps++
    36:	    }
=>  37:	        return startIdx == end
    38:	}
    39:	
    40:	func getMinOfGreater (arr []int, startIdx , val int) int {
    41:	    min := math.MaxInt
    42:	    next:=-1
(dlv) c
> main.getMinOfGreater() ./main.go:45 (hits goroutine(1):3 total:3) (PC: 0x10ad473)
	min: 9223372036854775807
	next: -1
Warning: listing may not match stale executable
    40:	func getMinOfGreater (arr []int, startIdx , val int) int {
    41:	    min := math.MaxInt
    42:	    next:=-1
    43:	    for i:=startIdx;i < len(arr);i++ {
    44:	        if arr[i]>val && arr[i]<min{
=>  45:	            min = arr[i]
    46:	            next = i
    47:	        }
    48:	    }
    49:	    return next
    50:	}
(dlv) c
> main.CanEnd() ./main.go:35 (hits goroutine(1):3 total:3) (PC: 0x10ad2cc)
	startIdx: 4
	jmps: 1
Warning: listing may not match stale executable
    30:	            startIdx = getMaxofSmaller (arr , startIdx , arr[startIdx])
    31:	            if startIdx == -1{
    32:	                break
    33:	            }            
    34:	        }
=>  35:	        jmps++
    36:	    }
    37:	        return startIdx == end
    38:	}
    39:	
    40:	func getMinOfGreater (arr []int, startIdx , val int) int {
(dlv) c
> main.CanEnd() ./main.go:37 (hits goroutine(1):3 total:3) (PC: 0x10ad333)
	end: 5
	startIdx: -1
	jmps: 2
Warning: listing may not match stale executable
    32:	                break
    33:	            }            
    34:	        }
    35:	        jmps++
    36:	    }
=>  37:	        return startIdx == end
    38:	}
    39:	
    40:	func getMinOfGreater (arr []int, startIdx , val int) int {
    41:	    min := math.MaxInt
    42:	    next:=-1
(dlv) c
> main.CanEnd() ./main.go:37 (hits goroutine(1):4 total:4) (PC: 0x10ad333)
	end: 5
	startIdx: -1
	jmps: 1
Warning: listing may not match stale executable
    32:	                break
    33:	            }            
    34:	        }
    35:	        jmps++
    36:	    }
=>  37:	        return startIdx == end
    38:	}
    39:	
    40:	func getMinOfGreater (arr []int, startIdx , val int) int {
    41:	    min := math.MaxInt
    42:	    next:=-1
(dlv) c
> main.CanEnd() ./main.go:37 (hits goroutine(1):5 total:5) (PC: 0x10ad333)
	end: 5
	startIdx: 5
	jmps: 1
Warning: listing may not match stale executable
    32:	                break
    33:	            }            
    34:	        }
    35:	        jmps++
    36:	    }
=>  37:	        return startIdx == end
    38:	}
    39:	
    40:	func getMinOfGreater (arr []int, startIdx , val int) int {
    41:	    min := math.MaxInt
    42:	    next:=-1
(dlv) c
(dlv) c
(dlv) q
